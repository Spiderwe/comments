/*
 Navicat Premium Data Transfer

 Source Server         : wcc
 Source Server Type    : MySQL
 Source Server Version : 50724
 Source Host           : localhost:3306
 Source Schema         : aboke

 Target Server Type    : MySQL
 Target Server Version : 50724
 File Encoding         : 65001

 Date: 22/03/2020 23:03:01
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for app01_article
-- ----------------------------
DROP TABLE IF EXISTS `app01_article`;
CREATE TABLE `app01_article`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `desc` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `create_time` date NOT NULL,
  `comment_num` int(11) NOT NULL,
  `up_num` int(11) NOT NULL,
  `down_num` int(11) NOT NULL,
  `blog_id` int(11) DEFAULT NULL,
  `category_id` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `app01_article_blog_id_8dd74ae6_fk_app01_blog_id`(`blog_id`) USING BTREE,
  INDEX `app01_article_category_id_acb2c466_fk_app01_category_id`(`category_id`) USING BTREE,
  INDEX `app01_article_user_id_ed7b2a20_fk_app01_userinfo_id`(`user_id`) USING BTREE,
  CONSTRAINT `app01_article_blog_id_8dd74ae6_fk_app01_blog_id` FOREIGN KEY (`blog_id`) REFERENCES `app01_blog` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `app01_article_category_id_acb2c466_fk_app01_category_id` FOREIGN KEY (`category_id`) REFERENCES `app01_category` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `app01_article_user_id_ed7b2a20_fk_app01_userinfo_id` FOREIGN KEY (`user_id`) REFERENCES `app01_userinfo` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of app01_article
-- ----------------------------
INSERT INTO `app01_article` VALUES (2, 'Docker Compose与Docker Stack的不同之处', '翻译原文 Docker引擎在1.12 版本集成了Docker Swarm, 带来了一些新工具。 现在可以无需安装 Docker Compose， 就可以利用docker-compose.yml 文件创建Docker 容器堆栈。 这个命令是 docker stack, 使用方式与docker-comp ...', '<div id=\"cnblogs_post_body\" class=\"blogpost-body \"><a name=\"_labelTop\"></a><div id=\"navCategory\"><blockquote><p style=\"font-size: 18pt; color:#a2b4ba\"><b>目录</b></p><div><a style=\"font-size:18px\" href=\"#1.-概述\">1. 概述</a><br><a style=\"font-size:18px\" href=\"#1.1-什么是声纹？\">1.1 什么是声纹？</a><br><a style=\"font-size:16px\" href=\"#1.2-声纹识别技术的历史\">  1.2 声纹识别技术的历史</a><br><a style=\"font-size:16px\" href=\"#1.3-声纹识别的种类\">  1.3 声纹识别的种类</a><br><a style=\"font-size:18px\" href=\"#2.-语音的特征提取方法概述\">2. 语音的特征提取方法概述</a><br><a style=\"font-size:16px\" href=\"#2.1-特征提取方法\">  2.1 特征提取方法</a><br><a style=\"font-size:16px\" href=\"#2.2-mfcc语音特征提取\">  2.2 MFCC语音特征提取</a><br><a style=\"font-size:16px\" href=\"#2.2.4-对信号进行离散傅立叶变换-dft\">  2.2.4 对信号进行离散傅立叶变换 (DFT)</a><br><a style=\"font-size:18px\" href=\"#3.-总结\">3. 总结</a><br><a style=\"font-size:18px\" href=\"#4.-参考资料\">4. 参考资料</a><br></div></blockquote></div>\r\n    <h1>1. 概述</h1>\r\n<p>　　语音是人类之间沟通交流的最直接也是最快捷方便的一种手段，而实现人类与计算机之间畅通无阻的语音交流，一直是人类追求的一个梦想。</p>\r\n<p>　　伴随着移动智能设备的普及，各家移动设备的厂家也开始在自家的设备上集成了语音识别系统，像Apple Siri、Microsoft Cortana、Google Now等语音助手的出现，使得人们在使用移动设备的同时，也能够进行语音交流，极大的方便了人们的生活。但是此类助手也存在一些尴尬的瞬间，例如在一些工作场合或者聚会的场合，某人的一句“Hey Siri”就可能唤醒多台苹果设备，使用者难免尴尬困惑。</p>\r\n<p>　　而此类予语音助手背后，均是一种被称作“闻声识人”的计算机技术，称为语音识别。语音识别技术属于生物认证技术，而其中的说话人识别（speaker recognize，SR）是其中的一种，该技术通常也被称为声纹识别技术，该技术是一项通过语音波形中反映说话人生理特征和行为特征的一组语音参数，自动识别说话人身份的技术。其核心是通过预先录入说话人的声音样本，提取出说话人独一无二的语音特征并存入数据库，应用的时候将待验证的语音进行特征提取并与数据库中的特征进行匹配，以确定说话人的身份。</p>\r\n<h1>1.1 什么是声纹？</h1>\r\n<p>　　声纹（voiceprint）是用电声学仪器显示的携带者言语信息的声波频谱，是由波长、频率以及强度等百余种特征维度组成的生物特征，具有稳定性、可测量性以及唯一性等特点。</p>\r\n<p>　　人类语言的产生是由人体语言中枢与发生器官之间进行的一个复杂的生物物理反应过程。发声器官如舌头、牙齿、喉咙、肺、鼻子在尺寸和形态上因人而异，所有任何两个人的声波图谱都有一定的差异性。</p>\r\n<p>每个人的语音声学特征既有相对稳定性，又有个体差异性。这种差异可能来自生理、病理、心理、模拟、伪装等，也可能会周围环境的干扰相关。</p>\r\n<p>　　由于每个人的发生器官都有其独特性，因此在一般情况下，人们仍然能区别不同的人的声音或者判断是否是同一个人的声音。</p>\r\n<p>　　声纹不像图像那样的直观，在实际的分析中，可以通过波形图和语谱图进行绘制展现，例如下图是一段从1到10的读数语音文件对应的波形图和语谱图（上部分为声音波形图，下部分为声音语谱图）：</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120204119-76471192.png\" alt=\"\" width=\"684\" height=\"513\"></p>\r\n<div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div>\r\n<pre><span style=\"color: #0000ff;\">import</span><span style=\"color: #000000;\"> wave\r\n</span><span style=\"color: #0000ff;\">import</span><span style=\"color: #000000;\"> numpy as np\r\n</span><span style=\"color: #0000ff;\">import</span><span style=\"color: #000000;\"> matplotlib.pyplot as plt\r\n\r\nfw </span>= wave.open(<span style=\"color: #800000;\">\'</span><span style=\"color: #800000;\">test.wav</span><span style=\"color: #800000;\">\'</span>,<span style=\"color: #800000;\">\'</span><span style=\"color: #800000;\">r</span><span style=\"color: #800000;\">\'</span><span style=\"color: #000000;\">)\r\nsoundInfo </span>= fw.readframes(-1<span style=\"color: #000000;\">)\r\nsoundInfo </span>=<span style=\"color: #000000;\"> np.fromstring(soundInfo,np.int16)\r\nf </span>=<span style=\"color: #000000;\"> fw.getframerate()\r\nfw.close()\r\n\r\nplt.subplot(</span>211<span style=\"color: #000000;\">)\r\nplt.plot(soundInfo)\r\nplt.ylabel(</span><span style=\"color: #800000;\">\'</span><span style=\"color: #800000;\">Amplitude</span><span style=\"color: #800000;\">\'</span><span style=\"color: #000000;\">)\r\nplt.title(</span><span style=\"color: #800000;\">\'</span><span style=\"color: #800000;\">Wave from and spectrogram of test.wav</span><span style=\"color: #800000;\">\'</span><span style=\"color: #000000;\">)\r\n\r\nplt.subplot(</span>212<span style=\"color: #000000;\">)\r\nplt.specgram(soundInfo,Fs </span>= f, scale_by_freq = True, sides = <span style=\"color: #800000;\">\'</span><span style=\"color: #800000;\">default</span><span style=\"color: #800000;\">\'</span><span style=\"color: #000000;\">)\r\nplt.ylabel(</span><span style=\"color: #800000;\">\'</span><span style=\"color: #800000;\">Frequency</span><span style=\"color: #800000;\">\'</span><span style=\"color: #000000;\">)\r\nplt.xlabel(</span><span style=\"color: #800000;\">\'</span><span style=\"color: #800000;\">time(seconds)</span><span style=\"color: #800000;\">\'</span><span style=\"color: #000000;\">)\r\nplt.show()</span></pre>\r\n<div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div>\r\n<ul>\r\n<li>语谱图更简单的绘制方法，可参考 <a href=\"https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.signal.spectrogram.html\" target=\"_blank\">scipy.signal.spectrogram</a>。</li>\r\n<li>语谱图绘制的原理，可参考 <a href=\"http://www.frank-zalkow.de/en/code-snippets/create-audio-spectrograms-with-python.html?i=1\" target=\"_blank\">Create audio spectrograms with Python</a>。</li>\r\n</ul>\r\n<p>　　与其他的生物认证技术如指纹识别、人脸识别、虹膜识别等相同，声纹识别具有不会遗忘、无需记忆和使用方便等优点。在生物认证技术领域，说话人识别技术以其独特的方便性、经济性和准确性收到人们的广泛关注，并日益成为人们日常生活和工作中重要且普及的安全认证方式。</p>\r\n<p>　　但是，说话人识别有着其他生物认证技术所不具有的优势：</p>\r\n<p>　　用户接受度高：以声音作为识别特征，因其非接触性和自然醒，用户易接受。用户不用刻意的用手指触摸相应的传感器上，也不用将眼睛凑向摄像头，只需要简单的说一两句话即可完成识别认证。</p>\r\n<p>　　设备成本低：对输入设备如麦克风，摄像头等没有特别的要求，特征提取，模型训练和匹配只需要普通的计算机即可完成。</p>\r\n<p>　　其他生物认证特征技术各有其劣势：指纹识别需要特殊的传感器芯片，虹膜识别精确度较高，但是设备较为昂贵。</p>\r\n<p>　　在远程应用和移动互联网环境下优势明显：通过电话、移动设备进行身份认证，声音是最具优势的生物特征，语音控制也逐渐成为流行的交互形式，以声音为特征的身份鉴别技术也越发重要。</p>\r\n<h2>1.2 声纹识别技术的历史</h2>\r\n<p>声纹识别技术的研究始于20世纪30年代，早期的工作主要集中于人耳听辨实验和探讨听音识别的可能性方面。随着研究手段和计算机技术的发展，研究工作逐渐脱离了单纯的人耳听辨，使得通过机器自动识别人的声音称为可能。在这个过程中也出现了很多不同的计算机技术，从早期的模板匹配到最新的深度学习技术，均在不断的刷新着语音识别技术手段。整体来看，声纹识别技术的发展经历了七个技术演进之路，详见下图（下图来自speakin）：</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120331963-48572140.png\" alt=\"\" width=\"608\" height=\"1520\"></p>\r\n<h2>1.3 声纹识别的种类</h2>\r\n<p>　　声纹识别根据实际应用的范畴可以分为 1:1识别 和 1:N识别两种：</p>\r\n<ul>\r\n<li>1:1识别：指确定待识别的一段语音是否来自其所声明的目标说话人，即确认目标说话人是目标说话人的过程。通常应用于电子支付、智能硬件、银行证券交易等。1:1识别有两个系统的性能评价参量，分别为\r\n<ul>\r\n<li>错误接受率(False Acceptation Rate, FAR)：将非目标说话人判别为目标说话人造成的错误率</li>\r\n<li>错误拒绝率(False Rejection Rate, FRR)：将目标说话人误识成非目标说话人造成的错误率</li>\r\n</ul>\r\n</li>\r\n<li>对安全性要求越高，则设定阈值越高，此时接受目标说话人的条件越严格，即FRR越高，FAR越低；对用户体验要求越高，则设定阈值越低，此时接受目标说话人的条件越宽松，即FAR越高，FRR越低。在声纹系统中，可以通过设定不同的阈值来平衡FAR和FRR。</li>\r\n<li>1:N识别：指判定待识别语音属于目标说话人模型集合中的哪一个人，即在N个人中找到目标说话人的过程。通常应用于公安司法、军队国防等。</li>\r\n</ul>\r\n<h1>2. 语音的特征提取方法概述</h1>\r\n<p>　　语音是一种数字信号，其数字⾳频的采样率为44100Hz（根据乃奎斯特取样定理得出的结果，在模拟讯号数字化的过程中，如果保证取样频率大于模拟讯号最高频率的2倍，就能100%精确地再还原出原始的模拟讯息。音频的最高频率为20kHz，所以取样率至少应该大于40kHz，为了留一点安全系数，再考虑到工程上的习惯，最终选择了44.1kHz这个数值）。通常情况下使用傅里叶变换将信号在时域与频域之间进行转换，而频谱图可以显示傅里叶变换后的振幅与时间和频率的对应关系。</p>\r\n<h2>2.1 特征提取方法</h2>\r\n<p>　　对于语音识别系统而言，所提取的特征参数需要能够反映特定发信的信息，在说话人无关的系统中，更要求参数能够反映不同说话人相同发音的信息，要求说话人的特征参数要能够代表特定的说话人，能够区分不同说话人相同语音之间的差异，最好能够做到与具体的发音内容无关，也称为文本无关。</p>\r\n<p>　　在语音特征参数提取技术的发展历程中，<a href=\"https://blog.csdn.net/qingkongyeyue/article/details/52149839\" target=\"_blank\">线性预测编码（Linear Predictive Coding, LPC）</a>被广泛应用于语音特征参数的提取，其中包括LPC系数、反射LPC系数、面积函数和LPC倒谱系数，能够很好的反映语音的声道特征，但是却对语音的其他特征无能为力。</p>\r\n<p>　　不同于LPC等通过对人的发声机理进行研究而得到的声学特征，Mel倒谱系数MFCC是受人的听觉系统研究成果推出而导出的声学特征。根据人耳听觉机理的研究发现，人耳对不同频率的声波有不同的听觉灵敏度。从200Hz到5000Hz的语音信号对语音的清晰度影响最大。人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征，对此特征经过进一步处理后就可以作为语音的输入特征。由于这种特征不依赖于信号的性质，对输入信号不做任何的假设和限制，又利用了听觉模型的研究成果。因此，这种参数比基于声道模型的LPC相比具有更好的鲁棒性，更符合人耳的听觉特性，而且当信噪比降低时仍然具有较好的识别性能。</p>\r\n<p>　　MFCC（MeI-Freguency CeptraI Coefficients）是需要语音特征参数提取方法之一，因其独特的基于倒谱的提取方式，更加的符合人类的听觉原理，因而也是最为普遍、最有效的语音特征提取算法。MFCC是在Mel标度频率域提取出来的倒谱系数，Mel标度描述了人耳对频率感知的非线性特性。</p>\r\n<h2>2.2 MFCC语音特征提取</h2>\r\n<p>MFCC 语音特征的提取过程，如下图：</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120506562-2064280186.png\" alt=\"\" width=\"1367\" height=\"284\"></p>\r\n<p>需要对语音信号进行预加重、分帧、加窗等等处理，而这些处理的方式均是为了能够最大化语音信号的某些信息，以达到最好特征参数的提取。</p>\r\n<h3>2.2.1 预加重</h3>\r\n<p>预加重其实就是将语音信号通过一个高通滤波器，来增强语音信号中的高频部分，并保持在低频到高频的整个频段中，能够使用同样的信噪比求频谱。在本实验中，选取的高通滤波器传递函数为：&nbsp;<img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120520197-1395193034.png\" alt=\"\"></p>\r\n<p>式中a的值介于0.9-1.0之间，我们通常取0.97。同时，预加重也是为了消除发生过程中声带和嘴唇的效应，来补偿语音信号受到发音系统所抑制的高频部分，也为了突出高频的共振峰。</p>\r\n<div class=\"cnblogs_code\">\r\n<pre><span style=\"color: #0000ff;\">def</span> pre_emphasis(signal, coefficient=0.97<span style=\"color: #000000;\">):\r\n    </span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #800000;\">对信号进行预加重</span><span style=\"color: #800000;\">\'\'\'</span>\r\n    <span style=\"color: #0000ff;\">return</span> numpy.append(signal[0], signal[1:] - coefficient * signal[:-1])</pre>\r\n</div>\r\n<h3>2.2.2 分帧</h3>\r\n<p>分帧是指在跟定的音频样本文件中，按照某一个固定的时间长度分割，分割后的每一片样本，称之为一帧，这里需要区分时域波形中的帧，分割后的一帧是分析提取MFCC的样本，而时域波形中的帧是时域尺度上对音频的采样而取到的样本。</p>\r\n<p>分帧是先将N个采样点集合成一个观测单位，也就是分割后的帧。通常情况下N的取值为512或256，涵盖的时间约为20-30ms。也可以根据特定的需要进行N值和窗口间隔的调整。为了避免相邻两帧的变化过大，会让两相邻帧之间有一段重叠区域，此重叠区域包含了M个取样点，一般M的值约为N的1/2或1/3。</p>\r\n<p>语音识别中所采用的信号采样频率一般为8kHz或16kHz。以8kHz来说，若帧长度为256个采样点，则对应的时间长度是256/8000×1000=32ms。本次实验中所使用的采样率(Frames Per Second)16kHz，窗长25ms（400个采样点），窗间隔为10ms（160个采样点）。</p>\r\n<div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div>\r\n<pre><span style=\"color: #0000ff;\">def</span> audio2frame(signal, frame_length, frame_step, winfunc=<span style=\"color: #0000ff;\">lambda</span><span style=\"color: #000000;\"> x: numpy.ones((x,))):\r\n    </span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #800000;\">分帧</span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #000000;\">\r\n    signal_length </span>=<span style=\"color: #000000;\"> len(signal)\r\n    frame_length </span>=<span style=\"color: #000000;\"> int(round(frame_length))\r\n    frame_step </span>=<span style=\"color: #000000;\"> int(round(frame_step))\r\n    </span><span style=\"color: #0000ff;\">if</span> signal_length &lt;=<span style=\"color: #000000;\"> frame_length:\r\n        frames_num </span>= 1\r\n    <span style=\"color: #0000ff;\">else</span><span style=\"color: #000000;\">:\r\n        frames_num </span>= 1 + int(math.ceil((1.0 * signal_length - frame_length) /<span style=\"color: #000000;\"> frame_step))\r\n    pad_length </span>= int((frames_num - 1) * frame_step +<span style=\"color: #000000;\"> frame_length)\r\n    zeros </span>= numpy.zeros((pad_length -<span style=\"color: #000000;\"> signal_length,))\r\n    pad_signal </span>=<span style=\"color: #000000;\"> numpy.concatenate((signal, zeros))\r\n    indices </span>= numpy.tile(numpy.arange(0, frame_length), (frames_num, 1)) + numpy.tile(numpy.arange(0, frames_num * frame_step, frame_step),(frame_length, 1<span style=\"color: #000000;\">)).T\r\n    indices </span>= numpy.array(indices, dtype=<span style=\"color: #000000;\">numpy.int32)\r\n    frames </span>=<span style=\"color: #000000;\"> pad_signal[indices]\r\n    win </span>= numpy.tile(winfunc(frame_length), (frames_num, 1<span style=\"color: #000000;\">))\r\n    </span><span style=\"color: #0000ff;\">return</span> frames * win</pre>\r\n<div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div>\r\n<h3>2.2.3 加窗</h3>\r\n<p>在对音频进行分帧之后，需要对每一帧进行加窗，以增加帧左端和右端的连续性，减少频谱泄漏。在提取MFCC的时候，比较常用的窗口函数为Hamming窗。</p>\r\n<p>假设分帧后的信号为 S(n),n=0,1,2…,N-1，其中N为帧的大小，那么进行加窗的处理则为：</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120615637-375595992.png\" alt=\"\"></p>\r\n<p>W(n)的形式如下：</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120622782-1378443835.png\" alt=\"\"></p>\r\n<p>不同的a值会产生不同的汉明窗，一般情况下a取值0.46。进行值替换后，W(n)则为：</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120628262-833485069.png\" alt=\"\"></p>\r\n<p>对应的汉明窗时域波形类似下图：</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120633882-2061324844.png\" alt=\"\"></p>\r\n<div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div>\r\n<pre><span style=\"color: #0000ff;\">def</span> deframesignal(frames, signal_length, frame_length, frame_step, winfunc=<span style=\"color: #0000ff;\">lambda</span><span style=\"color: #000000;\"> x: numpy.ones((x,))):\r\n    </span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #800000;\">加窗</span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #000000;\">\r\n    signal_length </span>=<span style=\"color: #000000;\"> round(signal_length)\r\n    frame_length </span>=<span style=\"color: #000000;\"> round(frame_length)\r\n    frames_num </span>=<span style=\"color: #000000;\"> numpy.shape(frames)[0]\r\n    </span><span style=\"color: #0000ff;\">assert</span> numpy.shape(frames)[1] == frame_length, <span style=\"color: #800000;\">\'</span><span style=\"color: #800000;\">\"frames\"矩阵大小不正确，它的列数应该等于一帧长度</span><span style=\"color: #800000;\">\'</span><span style=\"color: #000000;\">\r\n    indices </span>= numpy.tile(numpy.arange(0, frame_length), (frames_num, 1)) + numpy.tile(numpy.arange(0, frames_num * frame_step, frame_step),(frame_length, 1<span style=\"color: #000000;\">)).T\r\n    indices </span>= numpy.array(indices, dtype=<span style=\"color: #000000;\">numpy.int32)\r\n    pad_length </span>= (frames_num - 1) * frame_step +<span style=\"color: #000000;\"> frame_length\r\n    </span><span style=\"color: #0000ff;\">if</span> signal_length &lt;=<span style=\"color: #000000;\"> 0:\r\n        signal_length </span>=<span style=\"color: #000000;\"> pad_length\r\n    recalc_signal </span>=<span style=\"color: #000000;\"> numpy.zeros((pad_length,))\r\n    window_correction </span>= numpy.zeros((pad_length, 1<span style=\"color: #000000;\">))\r\n    win </span>=<span style=\"color: #000000;\"> winfunc(frame_length)\r\n    </span><span style=\"color: #0000ff;\">for</span> i <span style=\"color: #0000ff;\">in</span><span style=\"color: #000000;\"> range(0, frames_num):\r\n        window_correction[indices[i, :]] </span>= window_correction[indices[i, :]] + win + 1e-15<span style=\"color: #000000;\">\r\n        recalc_signal[indices[i, :]] </span>= recalc_signal[indices[i, :]] +<span style=\"color: #000000;\"> frames[i, :]\r\n    recalc_signal </span>= recalc_signal /<span style=\"color: #000000;\"> window_correction\r\n    </span><span style=\"color: #0000ff;\">return</span> recalc_signal[0:signal_length]</pre>\r\n<div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div>\r\n<h2>2.2.4 对信号进行离散傅立叶变换 (DFT)</h2>\r\n<p>由于信号在时域上的变换通常很难看出信号的特性，所有通常将它转换为频域上的能量分布来观察，不同的能量分布，代表不同语音的特性。所以在进行了加窗处理后，还需要再经过离散傅里叶变换以得到频谱上的能量分布。对分帧加窗后的各帧信号进行快速傅里叶变换得到各帧的频谱。并对语音信号的频谱取模平方得到语音信号的功率谱。设语音信号的DFT为：<img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120713840-758840509.png\" alt=\"\"></p>\r\n<p>能量的分布为：</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120719347-120865946.png\" alt=\"\"></p>\r\n<p>在本次实验中，采用DFT长度 N=512，结果值保留前257个系数。</p>\r\n<div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div>\r\n<pre><span style=\"color: #0000ff;\">def</span> deframesignal(frames, signal_length, frame_length, frame_step, winfunc=<span style=\"color: #0000ff;\">lambda</span><span style=\"color: #000000;\"> x: numpy.ones((x,))):\r\n    </span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #800000;\">加窗</span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #000000;\">\r\n    signal_length </span>=<span style=\"color: #000000;\"> round(signal_length)\r\n    frame_length </span>=<span style=\"color: #000000;\"> round(frame_length)\r\n    frames_num </span>=<span style=\"color: #000000;\"> numpy.shape(frames)[0]\r\n    </span><span style=\"color: #0000ff;\">assert</span> numpy.shape(frames)[1] == frame_length, <span style=\"color: #800000;\">\'</span><span style=\"color: #800000;\">\"frames\"矩阵大小不正确，它的列数应该等于一帧长度</span><span style=\"color: #800000;\">\'</span><span style=\"color: #000000;\">\r\n    indices </span>= numpy.tile(numpy.arange(0, frame_length), (frames_num, 1)) + numpy.tile(numpy.arange(0, frames_num * frame_step, frame_step),(frame_length, 1<span style=\"color: #000000;\">)).T\r\n    indices </span>= numpy.array(indices, dtype=<span style=\"color: #000000;\">numpy.int32)\r\n    pad_length </span>= (frames_num - 1) * frame_step +<span style=\"color: #000000;\"> frame_length\r\n    </span><span style=\"color: #0000ff;\">if</span> signal_length &lt;=<span style=\"color: #000000;\"> 0:\r\n        signal_length </span>=<span style=\"color: #000000;\"> pad_length\r\n    recalc_signal </span>=<span style=\"color: #000000;\"> numpy.zeros((pad_length,))\r\n    window_correction </span>= numpy.zeros((pad_length, 1<span style=\"color: #000000;\">))\r\n    win </span>=<span style=\"color: #000000;\"> winfunc(frame_length)\r\n    </span><span style=\"color: #0000ff;\">for</span> i <span style=\"color: #0000ff;\">in</span><span style=\"color: #000000;\"> range(0, frames_num):\r\n        window_correction[indices[i, :]] </span>= window_correction[indices[i, :]] + win + 1e-15<span style=\"color: #000000;\">\r\n        recalc_signal[indices[i, :]] </span>= recalc_signal[indices[i, :]] +<span style=\"color: #000000;\"> frames[i, :]\r\n    recalc_signal </span>= recalc_signal /<span style=\"color: #000000;\"> window_correction\r\n    </span><span style=\"color: #0000ff;\">return</span> recalc_signal[0:signal_length]</pre>\r\n<div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div>\r\n<p>下图是有频谱到功率谱的转换结果示意图：</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120801439-2069352890.png\" alt=\"\" width=\"599\" height=\"359\"></p>\r\n<h3>2.2.5 应用梅尔滤波器 (Mel Filterbank)</h3>\r\n<p>MFCC考虑到了人类的听觉特征，先将线性频谱映射到基于听觉感知的Mel非线性频谱中，然后转换到倒谱上。 在Mel频域内，人对音调的感知度为线性关系。举例来说，如果两段语音的Mel频率相差两倍，则人耳听起来两者的音调也相差两倍。Mel滤波器的本质其实是一个尺度规则，通常是将能量通过一组Mel尺度的三角形滤波器组，如定义有M个滤波器的滤波器组，采用的滤波器为三角滤波器，中心频率为 f(m),m=1,2…M，M通常取22-26。f(m)之间的间隔随着m值的减小而缩小，随着m值的增大而增宽，如图所示：</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120824417-696753772.png\" alt=\"\"></p>\r\n<p>从频率到Mel频率的转换公式为：</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120833822-1217634102.png\" alt=\"\"></p>\r\n<p>其中 f 为语音信号的频率，单位赫兹（Hz）。</p>\r\n<div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div>\r\n<pre><span style=\"color: #0000ff;\">def</span><span style=\"color: #000000;\"> hz2mel(hz):\r\n    </span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #800000;\">把频率hz转化为梅尔频率</span><span style=\"color: #800000;\">\'\'\'</span>\r\n    <span style=\"color: #0000ff;\">return</span> 2595 * numpy.log10(1 + hz / 700.0<span style=\"color: #000000;\">)\r\n\r\n</span><span style=\"color: #0000ff;\">def</span><span style=\"color: #000000;\"> mel2hz(mel):\r\n    </span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #800000;\">把梅尔频率转化为hz</span><span style=\"color: #800000;\">\'\'\'</span>\r\n    <span style=\"color: #0000ff;\">return</span> 700 * (10 ** (mel / 2595.0) - 1)</pre>\r\n<div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div>\r\n<p>假如有10个Mel滤波器（在实际应用中通常一组Mel滤波器组有26个滤波器。），首先要选择一个最高频率和最低频率，通常最高频率为8000Hz，最低频率为300Hz。使用从频率转换为Mel频率的公式将300Hz转换为401.25Mels，8000Hz转换为2834.99Mels，由于有10个滤波器，每个滤波器针对两个频率的样点，样点之间会进行重叠处理，因此需要12个点，意味着需要在401.25和2834.99之间再线性间隔出10个附加点，如：</p>\r\n<p><span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-1-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>m</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>401.25</mn><mo>,</mo><mn>622.50</mn><mo>,</mo><mn>843.75</mn><mo>,</mo><mn>1065.00</mn><mo>,</mo><mn>1286.25</mn><mo>,</mo><mn>1507.50</mn><mo>,</mo><mn>1728.74</mn><mo>,</mo><mn>1949.99</mn><mo>,</mo><mn>2171.24</mn><mo>,</mo><mn>2392.49</mn><mo>,</mo><mn>2613.74</mn><mo>,</mo><mn>2834.99</mn></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1\" style=\"width: 46.813em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 45.426em; height: 0px; font-size: 103%;\"><span style=\"position: absolute; clip: rect(1.182em, 1045.36em, 2.639em, -999.997em); top: -2.146em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-2\"><span class=\"mi\" id=\"MathJax-Span-3\" style=\"font-family: MathJax_Math-italic;\">m</span><span class=\"mo\" id=\"MathJax-Span-4\" style=\"font-family: MathJax_Main;\">(</span><span class=\"mi\" id=\"MathJax-Span-5\" style=\"font-family: MathJax_Math-italic;\">i</span><span class=\"mo\" id=\"MathJax-Span-6\" style=\"font-family: MathJax_Main;\">)</span><span class=\"mo\" id=\"MathJax-Span-7\" style=\"font-family: MathJax_Main; padding-left: 0.281em;\">=</span><span class=\"mn\" id=\"MathJax-Span-8\" style=\"font-family: MathJax_Main; padding-left: 0.281em;\">401.25</span><span class=\"mo\" id=\"MathJax-Span-9\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-10\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">622.50</span><span class=\"mo\" id=\"MathJax-Span-11\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-12\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">843.75</span><span class=\"mo\" id=\"MathJax-Span-13\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-14\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">1065.00</span><span class=\"mo\" id=\"MathJax-Span-15\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-16\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">1286.25</span><span class=\"mo\" id=\"MathJax-Span-17\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-18\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">1507.50</span><span class=\"mo\" id=\"MathJax-Span-19\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-20\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">1728.74</span><span class=\"mo\" id=\"MathJax-Span-21\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-22\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">1949.99</span><span class=\"mo\" id=\"MathJax-Span-23\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-24\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">2171.24</span><span class=\"mo\" id=\"MathJax-Span-25\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-26\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">2392.49</span><span class=\"mo\" id=\"MathJax-Span-27\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-28\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">2613.74</span><span class=\"mo\" id=\"MathJax-Span-29\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-30\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">2834.99</span></span><span style=\"display: inline-block; width: 0px; height: 2.153em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.354em; border-left: 0px solid; width: 0px; height: 1.146em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mi>m</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>401.25</mn><mo>,</mo><mn>622.50</mn><mo>,</mo><mn>843.75</mn><mo>,</mo><mn>1065.00</mn><mo>,</mo><mn>1286.25</mn><mo>,</mo><mn>1507.50</mn><mo>,</mo><mn>1728.74</mn><mo>,</mo><mn>1949.99</mn><mo>,</mo><mn>2171.24</mn><mo>,</mo><mn>2392.49</mn><mo>,</mo><mn>2613.74</mn><mo>,</mo><mn>2834.99</mn></math></span></span></div><script type=\"math/tex; mode=display\" id=\"MathJax-Element-1\">m(i) = 401.25,622.50,843.75,1065.00,1286.25,1507.50, 1728.74,1949.99,2171.24,2392.49,2613.74,2834.99</script></p>\r\n<p>现在使用从Mel频率转换为频率的公式将它们转换回赫兹：</p>\r\n<p><span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-2-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>h</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>300</mn><mo>,</mo><mn>517.33</mn><mo>,</mo><mn>781.90</mn><mo>,</mo><mn>1103.97</mn><mo>,</mo><mn>1496.04</mn><mo>,</mo><mn>1973.32</mn><mo>,</mo><mn>2554.33</mn><mo>,</mo><mn>3261.62</mn><mo>,</mo><mn>4122.63</mn><mo>,</mo><mn>5170.76</mn><mo>,</mo><mn>6446.70</mn><mo>,</mo><mn>8000</mn></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-31\" style=\"width: 43.901em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 42.583em; height: 0px; font-size: 103%;\"><span style=\"position: absolute; clip: rect(1.182em, 1042.51em, 2.639em, -999.997em); top: -2.146em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-32\"><span class=\"mi\" id=\"MathJax-Span-33\" style=\"font-family: MathJax_Math-italic;\">h</span><span class=\"mo\" id=\"MathJax-Span-34\" style=\"font-family: MathJax_Main;\">(</span><span class=\"mi\" id=\"MathJax-Span-35\" style=\"font-family: MathJax_Math-italic;\">i</span><span class=\"mo\" id=\"MathJax-Span-36\" style=\"font-family: MathJax_Main;\">)</span><span class=\"mo\" id=\"MathJax-Span-37\" style=\"font-family: MathJax_Main; padding-left: 0.281em;\">=</span><span class=\"mn\" id=\"MathJax-Span-38\" style=\"font-family: MathJax_Main; padding-left: 0.281em;\">300</span><span class=\"mo\" id=\"MathJax-Span-39\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-40\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">517.33</span><span class=\"mo\" id=\"MathJax-Span-41\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-42\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">781.90</span><span class=\"mo\" id=\"MathJax-Span-43\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-44\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">1103.97</span><span class=\"mo\" id=\"MathJax-Span-45\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-46\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">1496.04</span><span class=\"mo\" id=\"MathJax-Span-47\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-48\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">1973.32</span><span class=\"mo\" id=\"MathJax-Span-49\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-50\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">2554.33</span><span class=\"mo\" id=\"MathJax-Span-51\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-52\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">3261.62</span><span class=\"mo\" id=\"MathJax-Span-53\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-54\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">4122.63</span><span class=\"mo\" id=\"MathJax-Span-55\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-56\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">5170.76</span><span class=\"mo\" id=\"MathJax-Span-57\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-58\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">6446.70</span><span class=\"mo\" id=\"MathJax-Span-59\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-60\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">8000</span></span><span style=\"display: inline-block; width: 0px; height: 2.153em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.354em; border-left: 0px solid; width: 0px; height: 1.146em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mi>h</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>300</mn><mo>,</mo><mn>517.33</mn><mo>,</mo><mn>781.90</mn><mo>,</mo><mn>1103.97</mn><mo>,</mo><mn>1496.04</mn><mo>,</mo><mn>1973.32</mn><mo>,</mo><mn>2554.33</mn><mo>,</mo><mn>3261.62</mn><mo>,</mo><mn>4122.63</mn><mo>,</mo><mn>5170.76</mn><mo>,</mo><mn>6446.70</mn><mo>,</mo><mn>8000</mn></math></span></span></div><script type=\"math/tex; mode=display\" id=\"MathJax-Element-2\">h(i) = 300,517.33,781.90,1103.97,1496.04,1973.32,2554.33, 3261.62,4122.63,5170.76,6446.70,8000</script></p>\r\n<p>将频率映射到最接近的DFT频率：<img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928120945630-816430928.png\" alt=\"\"></p>\r\n<p><span class=\"MathJax_Preview\" style=\"color: inherit;\"></span><div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-3-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>9</mn><mo>,</mo><mn>16</mn><mo>,</mo><mn>25</mn><mo>,</mo><mn>35</mn><mo>,</mo><mn>47</mn><mo>,</mo><mn>63</mn><mo>,</mo><mn>81</mn><mo>,</mo><mn>104</mn><mo>,</mo><mn>132</mn><mo>,</mo><mn>165</mn><mo>,</mo><mn>206</mn><mo>,</mo><mn>256</mn></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-61\" style=\"width: 21.917em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 21.293em; height: 0px; font-size: 103%;\"><span style=\"position: absolute; clip: rect(1.182em, 1021.22em, 2.639em, -999.997em); top: -2.146em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-62\"><span class=\"mi\" id=\"MathJax-Span-63\" style=\"font-family: MathJax_Math-italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.073em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-64\" style=\"font-family: MathJax_Main;\">(</span><span class=\"mi\" id=\"MathJax-Span-65\" style=\"font-family: MathJax_Math-italic;\">i</span><span class=\"mo\" id=\"MathJax-Span-66\" style=\"font-family: MathJax_Main;\">)</span><span class=\"mo\" id=\"MathJax-Span-67\" style=\"font-family: MathJax_Main; padding-left: 0.281em;\">=</span><span class=\"mn\" id=\"MathJax-Span-68\" style=\"font-family: MathJax_Main; padding-left: 0.281em;\">9</span><span class=\"mo\" id=\"MathJax-Span-69\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-70\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">16</span><span class=\"mo\" id=\"MathJax-Span-71\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-72\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">25</span><span class=\"mo\" id=\"MathJax-Span-73\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-74\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">35</span><span class=\"mo\" id=\"MathJax-Span-75\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-76\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">47</span><span class=\"mo\" id=\"MathJax-Span-77\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-78\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">63</span><span class=\"mo\" id=\"MathJax-Span-79\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-80\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">81</span><span class=\"mo\" id=\"MathJax-Span-81\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-82\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">104</span><span class=\"mo\" id=\"MathJax-Span-83\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-84\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">132</span><span class=\"mo\" id=\"MathJax-Span-85\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-86\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">165</span><span class=\"mo\" id=\"MathJax-Span-87\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-88\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">206</span><span class=\"mo\" id=\"MathJax-Span-89\" style=\"font-family: MathJax_Main;\">,</span><span class=\"mn\" id=\"MathJax-Span-90\" style=\"font-family: MathJax_Main; padding-left: 0.142em;\">256</span></span><span style=\"display: inline-block; width: 0px; height: 2.153em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.354em; border-left: 0px solid; width: 0px; height: 1.146em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>9</mn><mo>,</mo><mn>16</mn><mo>,</mo><mn>25</mn><mo>,</mo><mn>35</mn><mo>,</mo><mn>47</mn><mo>,</mo><mn>63</mn><mo>,</mo><mn>81</mn><mo>,</mo><mn>104</mn><mo>,</mo><mn>132</mn><mo>,</mo><mn>165</mn><mo>,</mo><mn>206</mn><mo>,</mo><mn>256</mn></math></span></span></div><script type=\"math/tex; mode=display\" id=\"MathJax-Element-3\">f(i) = 9,16,25,35,47,63,81,104,132,165,206,256</script></p>\r\n<p>于是，我们得到了一个由10个Mel滤波器构成的Mel滤波器组。</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928121007550-1399517469.png\" alt=\"\"></p>\r\n<div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div>\r\n<pre><span style=\"color: #0000ff;\">def</span> get_filter_banks(filters_num=20, NFFT=512, samplerate=16000, low_freq=0, high_freq=<span style=\"color: #000000;\">None):\r\n    </span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #800000;\">计算梅尔三角间距滤波器，该滤波器在第一个频率和第三个频率处为0，在第二个频率处为1</span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #000000;\">\r\n    low_mel </span>=<span style=\"color: #000000;\"> hz2mel(low_freq)\r\n    high_mel </span>=<span style=\"color: #000000;\"> hz2mel(high_freq)\r\n    mel_points </span>= numpy.linspace(low_mel, high_mel, filters_num + 2<span style=\"color: #000000;\">)\r\n    hz_points </span>=<span style=\"color: #000000;\"> mel2hz(mel_points)\r\n    bin </span>= numpy.floor((NFFT + 1) * hz_points /<span style=\"color: #000000;\"> samplerate)\r\n    fbank </span>= numpy.zeros([filters_num, NFFT / 2 + 1<span style=\"color: #000000;\">])\r\n    </span><span style=\"color: #0000ff;\">for</span> j <span style=\"color: #0000ff;\">in</span><span style=\"color: #000000;\"> xrange(0, filters_num):\r\n        </span><span style=\"color: #0000ff;\">for</span> i <span style=\"color: #0000ff;\">in</span> xrange(int(bin[j]), int(bin[j + 1<span style=\"color: #000000;\">])):\r\n            fbank[j, i] </span>= (i - bin[j]) / (bin[j + 1] -<span style=\"color: #000000;\"> bin[j])\r\n        </span><span style=\"color: #0000ff;\">for</span> i <span style=\"color: #0000ff;\">in</span> xrange(int(bin[j + 1]), int(bin[j + 2<span style=\"color: #000000;\">])):\r\n            fbank[j, i] </span>= (bin[j + 2] - i) / (bin[j + 2] - bin[j + 1<span style=\"color: #000000;\">])\r\n    </span><span style=\"color: #0000ff;\">return</span> fbank</pre>\r\n<div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div>\r\n<h3>2.2.6 对频谱进行离散余弦变换 (DCT)</h3>\r\n<p>在上一步的基础上使⽤离散余弦变换，即进⾏了⼀个傅⽴叶变换的逆变换，得到倒谱系数。</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928121054701-2121813083.png\" alt=\"\"></p>\r\n<p>由此可以得到26个倒谱系数。只取其[2:13]个系数，第1个用能量的对数替代，这13个值即为所需的13个MFCC倒谱系数。</p>\r\n<div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div>\r\n<pre><span style=\"color: #0000ff;\">def</span> lifter(cepstra, L=22<span style=\"color: #000000;\">):\r\n    </span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #800000;\">升倒谱函数</span><span style=\"color: #800000;\">\'\'\'</span>\r\n    <span style=\"color: #0000ff;\">if</span> L &gt;<span style=\"color: #000000;\"> 0:\r\n        nframes, ncoeff </span>=<span style=\"color: #000000;\"> numpy.shape(cepstra)\r\n        n </span>=<span style=\"color: #000000;\"> numpy.arange(ncoeff)\r\n        lift </span>= 1 + (L / 2) * numpy.sin(numpy.pi * n /<span style=\"color: #000000;\"> L)\r\n        </span><span style=\"color: #0000ff;\">return</span> lift *<span style=\"color: #000000;\"> cepstra\r\n    </span><span style=\"color: #0000ff;\">else</span><span style=\"color: #000000;\">:\r\n        </span><span style=\"color: #0000ff;\">return</span> cepstra</pre>\r\n<div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div>\r\n<h3>2.2.7 动态差分参数的提取（包括一阶微分系数和加速系数）</h3>\r\n<p>标准的倒谱参数MFCC只反映了语音参数的静态特性，语音的动态特性可以用这些静态特征的差分谱来描述。通常会把动、静态特征结合起来以有效提高系统的识别性能。差分参数的计算可以采用下面的公式：</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190928121131104-1287605450.png\" alt=\"\"></p>\r\n<p>上式中，d(t)表示第t个一阶微分，c(t)表示第t个倒谱系数，Q表示倒谱系数的阶数，K表示一阶导数的时间差，可取1或2。将上式的结果再代入就可以得到加速系数。</p>\r\n<p>⾄此，我们计算到了了⾳频⽂件每⼀帧的39个Mel频率倒谱系数（13个MFCC+13个一阶微分系数+13个加速系数），这些即为一个语音文件的特征数据，这些特征数据可以运用在之后的分类中。</p>\r\n<div class=\"cnblogs_code\"><div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div>\r\n<pre><span style=\"color: #0000ff;\">def</span> derivate(feat, big_theta=2, cep_num=13<span style=\"color: #000000;\">):\r\n    </span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #800000;\">计算一阶系数或者加速系数的一般变换公式</span><span style=\"color: #800000;\">\'\'\'</span><span style=\"color: #000000;\">\r\n    result </span>=<span style=\"color: #000000;\"> numpy.zeros(feat.shape)\r\n    denominator </span>=<span style=\"color: #000000;\"> 0\r\n    </span><span style=\"color: #0000ff;\">for</span> theta <span style=\"color: #0000ff;\">in</span> numpy.linspace(1<span style=\"color: #000000;\">, big_theta, big_theta):\r\n        denominator </span>= denominator + theta ** 2<span style=\"color: #000000;\">\r\n    denominator </span>= denominator * 2\r\n    <span style=\"color: #0000ff;\">for</span> row <span style=\"color: #0000ff;\">in</span> numpy.linspace(0, feat.shape[0] - 1<span style=\"color: #000000;\">, feat.shape[0]):\r\n        tmp </span>=<span style=\"color: #000000;\"> numpy.zeros((cep_num,))\r\n        numerator </span>=<span style=\"color: #000000;\"> numpy.zeros((cep_num,))\r\n        </span><span style=\"color: #0000ff;\">for</span> t <span style=\"color: #0000ff;\">in</span> numpy.linspace(1<span style=\"color: #000000;\">, cep_num, cep_num):\r\n            a </span>=<span style=\"color: #000000;\"> 0\r\n            b </span>=<span style=\"color: #000000;\"> 0\r\n            s </span>=<span style=\"color: #000000;\"> 0\r\n            </span><span style=\"color: #0000ff;\">for</span> theta <span style=\"color: #0000ff;\">in</span> numpy.linspace(1<span style=\"color: #000000;\">, big_theta, big_theta):\r\n                </span><span style=\"color: #0000ff;\">if</span> (t + theta) &gt;<span style=\"color: #000000;\"> cep_num:\r\n                    a </span>=<span style=\"color: #000000;\"> 0\r\n                </span><span style=\"color: #0000ff;\">else</span><span style=\"color: #000000;\">:\r\n                    a </span>= feat[row][t + theta - 1<span style=\"color: #000000;\">]\r\n                </span><span style=\"color: #0000ff;\">if</span> (t - theta) &lt; 1<span style=\"color: #000000;\">:\r\n                    b </span>=<span style=\"color: #000000;\"> 0\r\n                </span><span style=\"color: #0000ff;\">else</span><span style=\"color: #000000;\">:\r\n                    b </span>= feat[row][t - theta - 1<span style=\"color: #000000;\">]\r\n                s </span>+= theta * (a -<span style=\"color: #000000;\"> b)\r\n            numerator[t </span>- 1] =<span style=\"color: #000000;\"> s\r\n        tmp </span>= numerator * 1.0 /<span style=\"color: #000000;\"> denominator\r\n        result[row] </span>=<span style=\"color: #000000;\"> tmp\r\n    </span><span style=\"color: #0000ff;\">return</span> result</pre>\r\n<div class=\"cnblogs_code_toolbar\"><span class=\"cnblogs_code_copy\"><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"//common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></span></div></div>\r\n<h1>3. 总结</h1>\r\n<p>　　本文针对语音数据的特征提取方法—MFCC进行了简单的概述和实践，MFCC是音频特征处理中比较常用而且很有效的方法。当特征数据提取出来之后，就可以进一步的进行数据的归一化、标准化，然后应用于机器学习、神经网络等等模型训练算法中，以得到能够识别语音类别的模型。在实际的应用中，可能还需要考虑很多的其他因素，例如源语音数据的采集方法、采集时长、模型的构建方式、模型的部署方式等等因素，因此需要根据业务的具体场景，来进行平衡取舍，以达到识别的时效性、准确性等。</p>\r\n<p>目前关于语音识别相关的研究还在持续中，目标是能够最小化成本的在移动端部署语音识别相关的功能，提高SDK在人工智能方便的能力等。</p>\r\n<h1>4. 参考资料</h1>\r\n<ul>\r\n<li><a href=\"https://en.wikipedia.org/wiki/Mel-frequency_cepstrum\" target=\"_blank\">Mel-frequency cepstrum</a></li>\r\n<li><a href=\"http://practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/\" target=\"_blank\">Mel Frequency Cepstral Coefficient (MFCC) tutorial</a></li>\r\n<li><a href=\"https://musicinformationretrieval.com/\" target=\"_blank\">Notes on Music Information Retrieval</a></li>\r\n<li><a href=\"http://www.cnblogs.com/daniel-D/p/3244718.html\" target=\"_blank\">机器学习中距离和相似性度量方法</a></li>\r\n<li><a href=\"https://robinchao.github.io/2018/07/24/speech-recognation-mfcc.html\" target=\"_blank\">https://robinchao.github.io/2018/07/24/speech-recognation-mfcc.html</a></li>\r\n</ul>\r\n<div id=\"signature\"><p>作者：<a href=\"http://www.cnblogs.com/LXP-Never/\">凌逆战</a><br>欢迎任何形式的转载，但请务必注明出处。<br>限于本人水平，如果文章和代码有表述不当之处，还请不吝赐教。<br>本文章不做任何商业用途，仅作为自学所用，文章后面会有参考链接，我可能会复制原作者的话，如果介意，我会修改或者删除。</p></div></div>', '2020-01-01', 2, 0, 0, 1, 1, 1);
INSERT INTO `app01_article` VALUES (3, '新手学习FFmpeg - 调用API完成视频的读取和输出', '在写了几个avfilter之后，原本以为对ffmpeg应该算是入门了。 结果今天想对一个视频文件进行转码操作，才发现基本的视频读取，输出都搞不定。 痛定思痛，仔细研究了一下ffmpeg提供的example，总结归纳读取处理视频文件的简要思路。 在读取，处理视频文件时，以下四个结构体是非常重要的，所以 ...', '<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\"><div id=\"nav\"><a class=\"newh3\" href=\"#缘起\" style=\"margin-left: 20px;\">缘起</a><br><a class=\"newh3\" href=\"#旧世界\" style=\"margin-left: 20px;\">旧世界</a><br><a class=\"newh4\" href=\"#classvisitor\" style=\"margin-left: 40px;\">ClassVisitor</a><br><a class=\"newh4\" href=\"#补丁\" style=\"margin-left: 40px;\">补丁</a><br><a class=\"newh3\" href=\"#间歇性跪\" style=\"margin-left: 20px;\">间歇性跪</a><br><a class=\"newh4\" href=\"#沟通\" style=\"margin-left: 40px;\">沟通</a><br><a class=\"newh4\" href=\"#蛛丝马迹\" style=\"margin-left: 40px;\">蛛丝马迹</a><br><a class=\"newh4\" href=\"#暂时维稳\" style=\"margin-left: 40px;\">暂时维稳</a><br><a class=\"newh3\" href=\"#新工程\" style=\"margin-left: 20px;\">新工程</a><br><a class=\"newh4\" href=\"#new出了null\" style=\"margin-left: 40px;\">new出了null</a><br><a class=\"newh4\" href=\"#prototype\" style=\"margin-left: 40px;\">prototype</a><br><a class=\"newh4\" href=\"#日志\" style=\"margin-left: 40px;\">日志</a><br><a class=\"newh4\" href=\"#简化\" style=\"margin-left: 40px;\">简化</a><br><a class=\"newh3\" href=\"#发布准备\" style=\"margin-left: 20px;\">发布准备</a><br><a class=\"newh4\" href=\"#cr\" style=\"margin-left: 40px;\">CR</a><br><a class=\"newh4\" href=\"#业务回归\" style=\"margin-left: 40px;\">业务回归</a><br><a class=\"newh4\" href=\"#虚惊一场\" style=\"margin-left: 40px;\">虚惊一场</a><br><a class=\"newh4\" href=\"#庙算几何\" style=\"margin-left: 40px;\">庙算几何</a><br><a class=\"newh3\" href=\"#决战时刻\" style=\"margin-left: 20px;\">决战时刻</a><br><a class=\"newh4\" href=\"#预发的启示\" style=\"margin-left: 40px;\">预发的启示</a><br><a class=\"newh4\" href=\"#发布文档\" style=\"margin-left: 40px;\">发布文档</a><br><a class=\"newh4\" href=\"#单测\" style=\"margin-left: 40px;\">单测</a><br><a class=\"newh4\" href=\"#小插曲\" style=\"margin-left: 40px;\">小插曲</a><br><a class=\"newh4\" href=\"#bean没有找到\" style=\"margin-left: 40px;\">Bean没有找到</a><br><a class=\"newh3\" href=\"#决战尾声\" style=\"margin-left: 20px;\">决战尾声</a><br><a class=\"newh4\" href=\"#电子发票同步\" style=\"margin-left: 40px;\">电子发票同步</a><br><a class=\"newh4\" href=\"#监控统计\" style=\"margin-left: 40px;\">监控统计</a><br><a class=\"newh3\" href=\"#小结\" style=\"margin-left: 20px;\">小结</a><br></div>\r\n    <p>说起来，也是一段比较有挑战有压力的经历。做完之后，有一种云淡风轻的感觉，故记之。<br>\r\n<br></p>\r\n<h3 id=\"缘起\">缘起</h3>\r\n<p>周二下午，忽报：QA 环境下单之后，订单搜索不出来了。</p>\r\n<p>略排查，发现订单记录并未同步到 ES 索引里。进一步发现，订单同步工程 S 虽然进程还在，但已经不再处理消息了。昨天因为一个项目的需求才测试过 QA 环境订单同步无问题，上午也没动静，怎么下午就突然报问题了呢？</p>\r\n<p>很快联想到，前两日，框架层发了通告：不再为使用了 3.2.x 以下 dubbo 版本的应用提供自动注册 dubbo 服务的能力。很可能是 S dubbo 版本过低，无法注册和访问 dubb 服务，无法进行订单同步，进而影响订单搜索和详情，严重阻塞了项目的测试。订单是核心嘛~~</p>\r\n<p>于是我将 pom 里的 dubbo 版本改成了 3.2.x 以上。可还是不行。要找框架同学一起排查下了。<br>\r\n<br></p>\r\n<h3 id=\"旧世界\">旧世界</h3>\r\n<h4 id=\"classvisitor\">ClassVisitor</h4>\r\n<p>框架同学东顺说，早上貌似改过 zan 版本，也许是这个导致的。于是，我请求降回到原来的版本，先解决问题再说。sadly，即使降回到原来的版本进行部署， S 的服务依然起不来。退路已断。</p>\r\n<p>框架同学子杰的第一个想法，是<strong>在本地启动调试</strong>。因为这样方便且高效。不过 S 应用已经很久没有在本地启动。而且 S 依赖比较多，在本地恐怕很难启动。</p>\r\n<p>报 ClassVisitor should be a interface , not a class 。此类错误通常是 jar 冲突导致。因此，我在工程里搜索了下 ClassVisitor ，果然发现有两个，一个是接口，一个是类。 看来要排掉那个有类 ClassVisitor 的 jar 包。</p>\r\n<pre class=\"java\"><code class=\"hljs\">       &lt;dependency&gt;\r\n            &lt;groupId&gt;com.xxx.platform&lt;/groupId&gt;\r\n            &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;\r\n            &lt;version&gt;<span class=\"hljs-number\">3.2</span>.7.3-RELEASE&lt;/version&gt;\r\n            &lt;exclusions&gt;\r\n                &lt;exclusion&gt;\r\n                    &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt;\r\n                    &lt;artifactId&gt;asm&lt;/artifactId&gt;\r\n                &lt;/exclusion&gt;\r\n            &lt;/exclusions&gt;\r\n        &lt;/dependency&gt;</code></pre>\r\n<p>排掉之后，就不再报这个错了。 然而， S 依然不处理消息。</p>\r\n<p>一边是测试同学在催促，一边是毫无头绪。心里有些急，可一时也想不到如何解决。子杰期望本地调试，可本地启动总是报奇怪的 groovy 不兼容错误。调了一晚上，终于把这个问题解决了。 但 S 依然不处理消息。<br>\r\n<br></p>\r\n<h4 id=\"补丁\">补丁</h4>\r\n<p>周三早上，继续战斗。子杰发了一段配置，让放在 S 工程的 XML 配置里。说这段配置是用来注册 dubbo 服务的。 加入之后，报错： <code>cause: Could not initialize class com.coreos.jetcd.api.KVGrpc, dubbo version: 1.0.1-SNAPSHOT, current host: x.x.x.x</code> 。 ZJ 说，这个错误之前见过，可能 protobuf 版本冲突了。</p>\r\n<pre class=\"java\"><code class=\"hljs\">     &lt;dependency&gt;\r\n            &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;\r\n            &lt;artifactId&gt;hbase-server&lt;/artifactId&gt;\r\n            &lt;version&gt;<span class=\"hljs-number\">1.2</span>.6&lt;/version&gt;\r\n            &lt;exclusions&gt;\r\n                &lt;exclusion&gt;\r\n                    &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;\r\n                    &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;\r\n                &lt;/exclusion&gt;\r\n            &lt;/exclusions&gt;\r\n        &lt;/dependency&gt;</code></pre>\r\n<p>排除 protobuf-java 包之后，终于可以起来了。 验证了下，订单同步 OK 了。 松了一口气。<br>\r\n<br></p>\r\n<h3 id=\"间歇性跪\">间歇性跪</h3>\r\n<p>才没轻松多久， 又跪了。又跪了。又跪了。又跪了。 测试同学又来催了。<br>\r\n<br></p>\r\n<h4 id=\"沟通\">沟通</h4>\r\n<p>在这种情形下，发生一点小“纠纷”总是可能的。有一次，在吃饭的时候，S 跪了。 测试同学群里喊：进度如何了，找到根本原因了么？ 心里有点恼火：作为开发，我肯定要尽职尽责尽早排查和解决问题；可是你也不能只是催，在这样尴尬的时刻，可以支援一下嘛。 不过，大家都很通情达理，我提供了“临时启动服务”的方法，测试同学就帮忙先启动服务了。</p>\r\n<p>反思一下，测试同学的做法也是合情合理的，因为他们要负责保障更大域范围的环境稳定，需要知道进度和原因。<strong>解决棘手问题时，同步进度和原因也是很重要的，心里应该装下更大的世界</strong>。此外，若我能及早同步“临时解决方案”，让测试同学知道怎么解决，也不会有这样的“纠纷”。<strong>有话好好说，总能找到更柔和的方式来解决。</strong></p>\r\n<p>于是我在群里回复：他们的担心和考虑是合理的，且已经快接近成功了。稍安。其实我也不知道距离成功还有多远。<br>\r\n<br></p>\r\n<h4 id=\"蛛丝马迹\">蛛丝马迹</h4>\r\n<p>排查问题，只能从错误日志里寻找一切蛛丝马迹。子杰找了一段 JVMExitHook 的代码，加在启动的时候，这样方便在进程退出的时候，打印一些线索。 不过，这招没起效果，打印出的信息似乎没有派上用场。</p>\r\n<p>同时，我也在仔细观察日志里出现的各种细微错误。不能放过一个嫌疑份子。确认了有四种可能的影响因素：1. 应用 M 跪； 2. Hbase 读写失败； 3. 脏数据； 4. 底层 jar 不兼容，导致某种隐藏的问题。<br>\r\n<br></p>\r\n<p><strong>M跪</strong></p>\r\n<p>又跪了。发现 S 有个任务访问 M 服务报错，登录机器，发现 M 服务跪了。重启 M 。 过了一段时间，S 又跪了，M 服务也跪了。会不会受了这个服务的影响呢 ？ 将 M 服务所涉及的任务暂时禁用了。将 M 禁用后，S 似乎就没有跪过了。</p>\r\n<p>M 报错的原因，是因为零售同学将一个接口迁移到了新的工程，也就是说，原来的接口下线了。 S 去注册这个接口的服务的时候找不到。<br>\r\n<br></p>\r\n<p><strong>HBase</strong></p>\r\n<p>发现有一些 HBase 写入失败。咨询 HBase 同学，是因为 QA 集群运行了一些离线任务，有时资源比较紧张。 虽然有疑点，但不太可能导致 S 跪。<br>\r\n<br></p>\r\n<p><strong>脏数据</strong></p>\r\n<p>在排查过程中，也发现有些脏数据，导致 NSQ 消息处理失败。脏数据可能把一个任务搞跪，不过 S 里有很多任务，要把 S 跪掉，还需要一些“道行” 吧。<br>\r\n<br></p>\r\n<p><strong>隐藏的坑</strong></p>\r\n<p>只是猜测，但确实是比较大的嫌疑。 因为前三者都是局部的影响，不太可能将 S 整个搞跪掉，但这个可能是全局的影响。比如说，某个 jar 版本的组件，与另一个组件交互，可能产生 bug , 吃内存，导致内存 OOM 。只是猜测。<br>\r\n<br></p>\r\n<h4 id=\"暂时维稳\">暂时维稳</h4>\r\n<p>子杰有了新的发现。从 dmsg 日志里看到，S 独占内存过多，Linux 内核将 S 的 java 进程 kill 掉了。调整了堆内存从 6.5G 到 4G，然后运行了一整天都没有跪。</p>\r\n<pre><code class=\"hljs yaml\"><span class=\"hljs-string\">java</span> <span class=\"hljs-string\">invoked</span> <span class=\"hljs-attr\">oom-killer:</span> <span class=\"hljs-string\">gfp_mask=0x201da,</span> <span class=\"hljs-string\">order=0,</span> <span class=\"hljs-string\">oom_adj=0,</span> <span class=\"hljs-string\">oom_score_adj=0</span>\r\n<span class=\"hljs-string\">java</span> <span class=\"hljs-string\">cpuset=/</span> <span class=\"hljs-string\">mems_allowed=0</span>\r\n<span class=\"hljs-attr\">Pid:</span> <span class=\"hljs-number\">4288</span><span class=\"hljs-string\">,</span> <span class=\"hljs-attr\">comm:</span> <span class=\"hljs-string\">java</span> <span class=\"hljs-string\">Not</span> <span class=\"hljs-string\">tainted</span> <span class=\"hljs-number\">2.6</span><span class=\"hljs-number\">.32</span><span class=\"hljs-bullet\">-754.9</span><span class=\"hljs-number\">.1</span><span class=\"hljs-string\">.el6.x86_64</span> <span class=\"hljs-comment\">#1</span>\r\n<span class=\"hljs-string\">[</span> <span class=\"hljs-number\">4286</span><span class=\"hljs-string\">]</span> <span class=\"hljs-number\">602</span> <span class=\"hljs-number\">4286</span> <span class=\"hljs-number\">3321904</span> <span class=\"hljs-number\">1898888</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-string\">java</span>\r\n<span class=\"hljs-string\">Out</span> <span class=\"hljs-string\">of</span> <span class=\"hljs-attr\">memory:</span> <span class=\"hljs-string\">Kill</span> <span class=\"hljs-string\">process</span> <span class=\"hljs-number\">4286</span> <span class=\"hljs-string\">(java)</span> <span class=\"hljs-string\">score</span> <span class=\"hljs-number\">929</span> <span class=\"hljs-string\">or</span> <span class=\"hljs-string\">sacrifice</span> <span class=\"hljs-string\">child</span>\r\n<span class=\"hljs-string\">Killed</span> <span class=\"hljs-string\">process</span> <span class=\"hljs-number\">4286</span><span class=\"hljs-string\">,</span> <span class=\"hljs-string\">UID</span> <span class=\"hljs-number\">602</span><span class=\"hljs-string\">,</span> <span class=\"hljs-string\">(java)</span> <span class=\"hljs-attr\">total-vm:13287616kB,</span> <span class=\"hljs-attr\">anon-rss:7595528kB,</span> <span class=\"hljs-attr\">file-rss:24kB</span></code></pre>\r\n<p><br></p>\r\n<h3 id=\"新工程\">新工程</h3>\r\n<p>QA 环境终于可以暂时安静一会了。 可是，生产环境如何解决呢？</p>\r\n<p>S 承载着公司亿级订单的同步，显然不能容忍用打补丁的方式来解决（何况这个补丁很恶心，会埋很大的坑），而且也无法接入 aladdin ，自动升级 jar 版本。 因此， QA 的做法，只能暂时维稳，不能用作生产环境的解决方案。</p>\r\n<p>咨询子杰 ，是否有办法可以以最小成本来改造 S 应用 ？ 回答：使用 youzan-boot 标准化工程。可是要改造成 youzan-boot 工程，势必改动很大，整个工程结构都变了，部署方式也变了，上线风险是很大的。对于 S 这样的应用，稍有不慎，就是 P1 或 P0 故障。</p>\r\n<p>进退两难。</p>\r\n<p>因为自己不太熟悉应用打包和部署的方式，有点畏难。但想了想，本质上就是把应用里的任务想办法启动起来。绝大部分代码都是可以复用的，只需要在新的工程结构中，将原来的启动代码嵌入进去。想到这里，有了一些信心，决定采用新工程的方式来解决这个问题。<br>\r\n<br></p>\r\n<h4 id=\"new出了null\">new出了null</h4>\r\n<p>根据子杰提供的文档及界面，很快建立了新的标准化脚手架工程。接着，将原工程的代码拷贝到新的工程里，并在启动的入口，将原来启动任务的类的方法添加进去。</p>\r\n<p>我是一个不解决主要问题寝食难安的人。深夜，继续。部署后，初始化任务出错。只好加日志，看看哪里抛异常了。不加不要紧，一加he一跳。<br>\r\n`<code>Task task = new Task();  logger.info(\"task:{}\", task) ，</code> 竟然打出了个 null !</p>\r\n<p>new 出了个 null ? 百思不得其解。想着，恐怕又没进展了， 打算睡觉了。正准备睡觉的时候，突然灵光一闪，去查看了下 toString 方法，是打印 task 实例中的 taskConfig 的，而此时 taskConfig 作为入参还没有设置到 task 中，因此打印为 null 。真是脑经急转弯啊。 遇到的每个问题，都是一道面试题。):</p>\r\n<p>看来，<strong>在程序的世界里，一切奇怪的事情，总有一个合理的缘由。</strong> 联想到前不久的 <a href=\"https://www.cnblogs.com/lovesqcc/p/11331168.html\" target=\"_blank\">“奇怪之事总有缘由：订单状态对比不一致问题排查”</a> ，有所领会。<br>\r\n<br></p>\r\n<h4 id=\"prototype\">prototype</h4>\r\n<p>继续排查为什么 task 没有正确初始化。对比原工程，发现 task 是一个声明为 prototype 的类，所引用的组件，也是 prototype 的。</p>\r\n<p>折腾到凌晨一点，终于能够看到，任务在消费消息了。奇怪的是，日志没有打出来 。先睡觉吧。<br>\r\n<br></p>\r\n<h4 id=\"日志\">日志</h4>\r\n<p>第二天一大早，就去找 DS 排查日志为什么没找到。DS 在一个 undefined.home 的目录下找到了日志文件。 日志路径的配置有问题。 按照 DS 的指点，导入了标准的 XML 日志配置，在期望的目录打印了任务处理日志。略开怀。</p>\r\n<p>可错误日志没打出来。这也是要命的事情。在发布线上的过程中，若没有错误日志的提醒，那是冒着枪林弹雨的冲锋，是容易中弹身亡的。</p>\r\n<p>DS 指点：可以直接把原来的文件拷贝过来亦可。错误日志终于打出来了！ 开心 ！~~ 又前进了一步，more closed to success。</p>\r\n<p>打印日志到本地磁盘之后，还要上报到公司内部的日志平台上，方便查看多台服务器的日志。照葫芦画瓢，折腾了下，搞定了。喜。<br>\r\n<br></p>\r\n<h4 id=\"简化\">简化</h4>\r\n<p>至此，新工程的整体和主要部分没问题了。还需要做一些简化，比如去掉一些无用的模块和文件，优化 pom 里的 jar 引用等，保持工程的简洁与干净，没有赘余。<br>\r\n<br></p>\r\n<h3 id=\"发布准备\">发布准备</h3>\r\n<p>接下来就要考虑发布了。<br>\r\n<br></p>\r\n<h4 id=\"cr\">CR</h4>\r\n<p>工程改动太多了，有点失控的感觉。 在发布之前，找几位有经验的同学帮忙一起 check 下是明智的选择，也是必经的流程。一位是一直帮我排查 QA 同步问题的子杰同学， 一位是见识比较广能力不错的王立同学，因为他作为后端同学解决了react 容器部署的问题，让 S 的新界面又重新问世啦！靠谱，厉害！还有一位是我的有伴水王，也是很踏实的。</p>\r\n<p><br></p>\r\n<h4 id=\"业务回归\">业务回归</h4>\r\n<p>CR 的同时，也要验证这个工程是否能保证原有的任务都能正常进行。</p>\r\n<p>前面谈到， 订单同步使得搜索和详情的任务都是 OK 的，也就是最重要的任务没问题；</p>\r\n<p>有些任务是与第三方交互的，在 QA 是无法验证的。 好在：这个工程里绝大部分都是访问 DB， ES， HBase 的组件，绝大多数的业务逻辑都在配置的任务里。可以说是<strong>“将基础技术设施与业务逻辑相分离而实现配置化“</strong>的典范做法。因此，从基本层面看，只要验证部分任务， 覆盖到所有的组件类别， 就可以看作是验证了所有任务。</p>\r\n<p>既可以把这种做法看成一种巧妙的方式，也可以看作是某种取巧和偷懒。这种方式还是会有漏网之鱼。<br>\r\n<br></p>\r\n<h4 id=\"虚惊一场\">虚惊一场</h4>\r\n<p>使用新工程部署之后，一直在观察中，没有跪过。 有点安心了。 在发布前晚，突然发现： 跪掉了。 天 ！ 难道还有什么细坑 ？又得继续观察和排查细坑了 ！ 恐怕要延期发布了。</p>\r\n<p>幸好，当天早上， 有伴告诉我，他重启过一次，运维同学也重启过一次，但是没启动成功。 我立即想到，可能他们是用老的 zan 版本启动的， 因为不兼容导致失败。我用 zan 的新版本启动是 OK 的。</p>\r\n<p>很快确认了这一点， 虚惊一场。<br>\r\n<br></p>\r\n<h4 id=\"庙算几何\">庙算几何</h4>\r\n<p>孙子曰：“夫未战而庙算胜者，得算多也，未战而庙算不胜者，得算少也；多算胜，少算不胜，而况于无算呼？”</p>\r\n<p>距离计划发布时间只有几个小时了。 这个工程的发布胜算在 92% 以上， 有 8% 的不确定性。胜算如下：</p>\r\n<ol>\r\n<li>最主要的订单同步任务是没有问题的；</li>\r\n<li>十几个的任务及子路径，我验证了大部分是可以正确输出的；</li>\r\n<li>组件代码无改动，只是工程结构变了；</li>\r\n<li>在 QA 和 预发环境运行稳定。</li>\r\n</ol>\r\n<p>不确定性如下：</p>\r\n<ol>\r\n<li>有一个任务是外部交互的，无法验证； 四个任务是边缘业务，不太好构造测试用例； 但这些任务所使用的组件，都在其他被验证过的任务中使用过了，因此，理论上也应该是间接被验证了；其实是有点懒，结果是受了惩罚。</li>\r\n<li>引入了 youzan-boot 的包，还有以前工程里的 jar 包，可能存在一些细微的不兼容的坑，未被发现。</li>\r\n</ol>\r\n<p>不管怎样， 胜算还是很大的。在发布的时候，再细心一些， 应该不会出什么问题。<br>\r\n<br></p>\r\n<h3 id=\"决战时刻\">决战时刻</h3>\r\n<h4 id=\"预发的启示\">预发的启示</h4>\r\n<p>在预发部署的时候，发现新的进程并没有正常起来，必须先手动 kill 掉原来的进程，再部署新的工程，才能让新进程正常启动和运行服务。 这一点尤为重要， 否则很容易出问题。</p>\r\n<p><strong>如果能对预发出现的问题敏锐地感知，有时预发的问题真的是神明的指示。</strong> 前不久做过的一个项目中，需要做一些交易配置的变更。在预发验证拼团订单的时候，订单状态没有正常流转，经排查日志发现：预发的请求竟然发到线上去了！ 联系营销同学得知，订单的后续通知，取决于接收最后一个参团订单的请求的机器所处的环境。比如说吧，拼团发起者的下单请求在 T1 机器， 拼团参团者的下单请求在 T2 机器上。 机器 T1 切换到了新的配置， T2 还没有。 此时， T2 将向营销发送消息，营销处理消息完成后，向交易机器 T3 发送回送消息。如果 T3 还没有切新配置，就可能导致走不下去。 发现这个问题后， 仔细思考了下，发现在 下午正常发布窗口发布是有风险的。因为如果正好在那个时间段有很多拼团活动，势必会导致很多拼团订单的状态流转有问题，不仅会对商家的交易有影响，还要应对后续复杂麻烦的数据修复。 想想，还是辛苦一点，凌晨发布好了， 此时拼团活动极少， 且有更多时间来验证项目改动和回归业务。</p>\r\n<p>经过沟通，决定在凌晨发布。安全上线。<br>\r\n<br></p>\r\n<h4 id=\"发布文档\">发布文档</h4>\r\n<p>由于要赶在新进程起来之前手动 kill 老进程，这个时机得把握好， 为了避免误操作，临阵手忙脚乱，因此，必要写个发布文档， 写清楚每一个步骤要执行的命令， 在真正发布的时候，只要简单的复制粘贴就可以了。</p>\r\n<p>本来想把这些命令写成一个脚本，可是 kill 老进程的执行要切换用户，一时间没有太多时间调试这个，且要执行的批量命令也不多， 因此，还是直接复制粘贴了。好在发布的时候，机器的编号是逐渐递增的，可以预测每批次发哪几台机器， 这就容易多了：只要在每批次发布之前，先 kill 掉将要发布的机器的老进程即可。</p>\r\n<p>会影响线上服务么？ 由于还有其他服务器在处理消息，且凌晨的消息量极少，因此 kill 几台机器的进程不会对线上服务有影响。<br>\r\n<br></p>\r\n<h4 id=\"单测\">单测</h4>\r\n<p>写好发布文档之后，已经 十一点半了。 该提发布申请了。</p>\r\n<p>在提发布申请之前，得先运行并单测全部通过。到单测平台上运行了下，发现报错： groovy 与 spock-core 的版本不兼容。</p>\r\n<p>郁闷了。在本地运行是 OK 的，为啥在这个节骨眼报错了。 看了下工程的配置，还是比较老的版本。想想可以升级到较新的版本，对任务运行应该没有影响。于是从核心工程拷贝了更新的版本号，并修复了一个单测文件。</p>\r\n<p>为了简单，根据报错只把 groovy 的版本升到了 2.0.1 ， —— 给自己买了个坑。<strong>在程序的世界里，因果命中注定。</strong><br>\r\n<br></p>\r\n<h4 id=\"小插曲\">小插曲</h4>\r\n<p>突然想到， 除了 S ，还有一个附属应用 s， 代码与 S 相同 ，但只运行对比任务。嗯， 这个应用也要发布， 也在预发验证下。</p>\r\n<p>我在 QA 也部署了应用 s ，可启动日志显示：访问交易配置表报错了：用户名被拒绝。这是怎么回事呢？ 在发布之前，有一些配置变更我提交了。我想到应该是运维同学更新过，不会有问题。 QA 没法验证， 只好上预发验证了。</p>\r\n<p>于是，我在预发也部署了 s 应用。启动日志没报错，可也没消费日志。想了想，也许之前就没有吧。 应该是 OK 的，就做发布前的准备去了。</p>\r\n<p>突然被拉到一个群里，是预发交易配置库访问出错排查。由于我集中精力在准备发布，因此对这个并未投以太多关注。但群里好像说是比较严重的事情，坚持要查明白，似乎说我故意配错了用户名和密码，以致于访问到错误的地方，险些造成安全事故，还连累了很多同学耗费时间来查问题。可我只是提交了被别人改动的配置（并且我相信是运维同学改动且应该是正确的），并没做出格的事情。难道，我一不留神就犯下了错误 ？</p>\r\n<p>事情原委是：DBA 同学杨大侠监控到交易配置库有大量访问错误，而且还来自于不同的机房，认为这是很大的不合理。初步排查到，访问出错来自于预发的 s 应用。这有什么关联呢？ 我一时也有点懵逼，仿佛处于云山雾绕。<br>\r\n<br></p>\r\n<p>####&amp;amp;####</p>\r\n<p>我提交了发布申请，开始发布 s 应用。未料，线上也报错了。这可奇怪了，我对比了下 S 与 s 的 交易配置表的用户名和密码，完全一样的啊 ！ 在 跳板机上用 mysql 连接了下，也是通的； S 在预发部署也没报错，这可奇怪了。</p>\r\n<p>杨大侠提醒： DB 连接的 jdbcURL中有 <code>&amp;amp;</code> 这样的字符。 我突然想到了， 在 QA 遇到过这个问题，因为高版本的 mysql 不支持这个老的语法，需要将这个变成 &amp; 本身。</p>\r\n<p>哪里还藏有 <code>&amp;amp;</code> 这个字符呢 ？ 重新再check 了下 s 应用的配置。 发现，交易配置表的配置有两处，其中一处是完全一样的，但还有一处。 重复出现的 DB 配置，真坑啊！</p>\r\n<p>修改之后，就没有报错了。DBA 监控也没有报错了。 排查这个错误耗费了将近三个小时。发布完 s 应用后，已经三点了。<br>\r\n<br></p>\r\n<h4 id=\"bean没有找到\">Bean没有找到</h4>\r\n<p>S 应用的发布似乎顺利一些。发了几台，没有报 DB 访问错误，或者其他奇怪的错误。</p>\r\n<p>四点半了， 刚发了几台机器，发现有错误： RefundBizNsqInput 的 bean 找不到，任务启动报错。这个任务是消费退款消息，写入退款数据，供订单导出来计算退款状态及金额的。如果这个数据有误，可能会影响订单状态的展示，误导商家发货。</p>\r\n<p>内心有点崩溃。 这可怎么办呢？ 继续发布完成 ？ 这样会导致这个任务大量报错， 退款消息无法消费， 引起上述问题， 造成故障； 如果暂停发布，等待下午发布，一则现在新老混布有较大风险，二则下午发布风险更大； 重新发布，已经快到 5 点的发布截止窗口了，稍有延迟，就要走紧急发布了。</p>\r\n<p>思前想后，还是趁这会清净，赶紧发完吧。于是，我紧急看了下代码，发现 RefundBizNsqInput 不在组件自动 scan 的包路径下。 于是将这个任务涉及的组件类都移到了可以被自动扫描组件的路径下，修复了下单测。此刻，如果要再验证 OK 再发布的话，恐怕会耗时太长。 于是，我做了个大胆的决定，不验证就直接发布。因为只是通过 IDE 的重构功能挪了下包路径，理论上是不会有问题的。 其实心里还是有点虚的。<strong>有时，直觉很重要，虽然它来自于大量经验的积累；当机立断也很重要。 </strong></p>\r\n<p>想定，取消了之前的发布单，联系运维同学，帮忙重新开了个紧急发布的绿灯， 重新开始发布。幸运的是，这次没有再报错误日志。于是，我按照写好的发布文档，一个人在这静静的天亮时分，按部就班地开始发布， 一直发了两个小时，到七点半多才发完，一如 08 年踏雪归来的感觉。</p>\r\n<p>反思： 如果在 QA 有验证那个退款消息的任务， 就不会出现这个尴尬的局面了。因为这个任务的消息处理，需要加载一个自定义的 消息接收器，而这个没有被覆盖到。 这是一条漏网之鱼。</p>\r\n<p><br></p>\r\n<h3 id=\"决战尾声\">决战尾声</h3>\r\n<h4 id=\"电子发票同步\">电子发票同步</h4>\r\n<p>正要鸣金收兵，忽现新军情：电子发票索引同步的一队小骑兵，趁我困倦之时，偷袭过来，想来个以逸待劳。任务里的一段 groovy 脚本无法执行。有几条消息就出错几条。得赶紧解决，不然线上又要报问题了。</p>\r\n<p>排查这个错误，有点尴尬。 错误日志只打印了： failed to execute 。。。 啥信息也没有。 我总不可能添加一行日志， 再发布一次吧。近乎崩溃。怎么办怎么办 ？ 扫了一眼脚本，有个奇怪的格式化日期的变量似乎没定义。想用另一种先替换看看。没效果。试来试去，没效果。</p>\r\n<p>此刻，有点难以承载思考了，有点扛不住了。 怎么办 ？ 思来想去，只好打扰一下团队同学了。 叫醒了三位懂些 groovy 的同学，帮忙一起排查下。</p>\r\n<p>KP 同学提醒说，在本地运行下这个脚本。 我马上想到了，可以把消息和脚本放到本地工程里运行下，看看哪里报错。那个被怀疑的变量也找到了定义的地方。在本地运行是通过的。 这可让人有点摸不着头脑了。 天已经亮了，八点多了。</p>\r\n<p>有同学建议说，回滚吧。可是，回滚的代价太大了。 花了一整晚，终于将老的工程迁移到新的工程， 难道要因为一个小的问题，再滚回到原来的 ？ 且新的工程回滚到老的，也是有比较大的风险的，发布也要经过一系列比较繁琐的操作，容易出错。 我宁可背一个 P4 故障，也要把这个问题解决掉。已经没有退路了。</p>\r\n<p>突然灵光一闪，可以在预发起相同的任务，然后加调试日志，在预发看看是什么缘故 。 燃起了新的希望。</p>\r\n<p>用最后的精力折腾了一下， 发现报 unable to solve groovy.json.JsonSlurper 。 我以为是没有 import ，因此加了一行 import 。可是还是报错。 KP 同学说 JsonSlurper 这个类没有找到啊，且最好把 groovy-all 也引用进去吧。关键的一击啊 ！ 我马上去工程里看了下，groovy 2.0.8 才支持 JsonSlurper ，而我之前为了单测通过，只用了 groovy 2.0.1 。 细心的读者应该注意到，前面跑单测的时候，我把 groovy 的版本改成了 2.0.1 。 因果的命中注定 ，是说，<strong>在你写下这行代码或配置的时候，命运已经注定了，只待前来认领。要慎重啊！ </strong></p>\r\n<p>立即修改，部署到预发， 解决了。 耶 ！！</p>\r\n<p>线上消费出错怎么办呢 ？ 先用预发的任务消费线上的消息吧，确保后续的数据都写入 OK ， 待明天做个优化后，再切回到线上的任务消费。原来预发可以作为线上的 “备胎” 啊！</p>\r\n<p>反思： 不用说，这个任务也没回归到，因为很边缘。 然而，这个任务引用了一个类，依赖更高版本的 groovy ，是个局部细节问题，没有覆盖到。 看来， <strong>凡有疏忽，必受惩罚。</strong> 老天爷的惩罚还是比较轻的： 照这样算下来，胜算大抵只有 80% 左右。</p>\r\n<p>终于可以碎觉了。 emm.... 别打扰我。<br>\r\n<br></p>\r\n<h4 id=\"监控统计\">监控统计</h4>\r\n<p>下午来到公司， 王爷 跟我说， S 的监控统计不对劲， 曲线值很低，跟业务量完全不匹配。我想，可能是日志平台又出问题了 ？ 之前间歇性也会这样。但王爷坚持要查一下。于是，我开完一个会之后，就找日志平台的同学苏苏一起去查了。</p>\r\n<p>苏苏显然更相信自己抓包看到的数据，说，这个业务量可能就是这样。但我深知，业务量肯定不是这样，更可能是改造工程的过程中，某个配置有问题，但暂时不知道是哪里有问题。</p>\r\n<p>不过苏苏查底层问题，明显很有章法。在经过我认可后，在机器上安装工具，抓包，看监控图表，发现 在 S 发布点之后，写监控统计就一直报错了。查来查去，发现 S 引用了一个自研轻量级 R 的包，来写入监控数据， R 则会读取 S 的一个配置文件，而这个文件的 NSQ 配置是错误的。至此，真相大白。</p>\r\n<p>想到之前还没仔细看过监控统计的代码，领悟： <strong>每一个不清楚的想要暂时跳过的地方， 老天爷都会恩赐一个问题， 逼着你最终弄清楚。</strong></p>\r\n<p><br></p>\r\n<h3 id=\"小结\">小结</h3>\r\n<p>像是走过了一段较长的路。 面对大流量下的大改动的发布，曾经感觉到比较大的压力。发布完成之后，感觉似乎没那么可怕了。 一切都过去了。</p>\r\n<p>流量汹似海，心内亦平川。 平常心就好。<br>\r\n<br></p>\r\n\r\n<div id=\"mycopyright\"><p>作者：<a target=\"_blank\" href=\"https://github.com/shuqin\">@琴水玉</a></p><p>转载请注明出处：<a class=\"uri\" href=\"https://www.cnblogs.com/lovesqcc/p/11602540.html\">https://www.cnblogs.com/lovesqcc/p/11602540.html</a></p></div></div>', '2020-01-01', 0, 0, 0, 1, 2, 1);
INSERT INTO `app01_article` VALUES (4, '了解一下Java SPI的原理', '了解一下Java SPI的原理 1 为什么写这篇文章？ 近期，本人在学习dubbo相关的知识，但是在dubbo官网中有提到Java的 SPI，这个名词之前未接触过，所以就去看了看，感觉还是有很多地方有使用的，比如jdbc、log相关的技术上均有使用，还是很有用处的，就在这里总结一下自己的学习内容！（ ...', '<div id=\"cnblogs_post_body\" class=\"blogpost-body \">\r\n    <p><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">上一篇文章强调了bean定义注册占Spring应用的</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">半壁江山</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">。而且详细介绍了两个重量级的注册bean定义的类。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">今天就以</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">SpringBoot</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">为例，来看看整个SpringBoot应用的bean定义是如何注册进容器的。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">先来看看经典的启动入口，如下图01：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221421860-1978977974.png\" alt=\"\"></p>\r\n<p><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\">可以看到调用的是run方法，并把</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">主类</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">（main或primary）作为第一个参数出入。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">接下来要做的事情，就是</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">顺藤摸瓜</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">，看看到底发生了什么，并确定下</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">究竟哪些类被注册了bean定义</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">此时，我就是一个快乐的小侦探，OK，走起。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">上面的调用走到了这里，如下图02：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221429408-984793344.png\" alt=\"\"></p>\r\n<p><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">可以看到把第一个参数（即主类）放入数组里，又调用了一个run方法，如下图03：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221434760-596207857.png\" alt=\"\"></p>\r\n<p><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">使用第一个参数（即主类）去调用了构造函数，得到了实例对象，然后又调用了实例的run方法。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">顺着构造函数走下去，最终走到了这里，如图04：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221440049-1944700939.png\" alt=\"\"></p>\r\n<p><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">发现最终主类被，放到Set&lt;Class&lt;?&gt;&gt;类型的primarySources字段中。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><strong style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">编程新说注</span></strong><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">：</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">通过搜索全类，发现这个字段除了刚刚放入的主类外，</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">再没有放入其它类</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">接着再沿着run方法往下走，来到了这里，如下图05：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221446029-1420789616.png\" alt=\"\"></p>\r\n<p><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">首先定义了一个容器类的变量，然后创建容器类的实例，就是通过反射调用构造函数了。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">然后就是准备容器，进入方法里看看，如下图06：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221504316-70083205.png\" alt=\"\"></p>\r\n<p><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">在方法最后终于看到了我们期望的，即bean定义的注册。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">发现要注册的资源是getAllSources()这个方法返回的，那就进去看看吧，如下图07：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221514704-1152867512.png\" alt=\"\"></p>\r\n<p><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">看到资源来自于</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">primarySources</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">字段和</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">sources</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">字段。第一个字段上文已经讲了，只包含主类。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><strong style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">编程新说注</span></strong><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">：通过搜索全类，发现第二个字段sources是</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">null</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">，</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">因此它不包含资源</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">因此，真正获取到的用于注册bean定义的资源</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">只有主类自己</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">那就打破砂锅走到底，继续吧。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">再来看看load方法，如下图08：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221521489-1216751866.png\" alt=\"\"></p>\r\n<p><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">使用刚刚获取到的资源创建了</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">BeanDefinitionLoader</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">类的实例。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ac39ff;\">这个类是SpringBoot定义的，类似于一个门面，因为它包含了所有注册bean定义的方式。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">这个类就是最后一步了，因此来看看，如下图09：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221528245-539431757.png\" alt=\"\"></p>\r\n<p><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">首先是一个Object[]类型（之所以用Object，是因为资源类型有多种）的sources字段，用于存储刚刚获取的资源。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">剩下四个都是用来注册bean定义的，其中两个上一篇已经讲过。</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">剩余两个是处理xml和groovy的，一个已经过时，一个尚未流行。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">最后再来看一眼，生成实例时调用的构造函数，如下图10：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221534605-1115044685.png\" alt=\"\"></p>\r\n<p><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">就是对五个字段的赋值或实例化，并无特别之处。</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">（其实是有的，先卖个关子）</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">接下来就是根据资源的具体类型，使用四个bean定义注册类中的一个来注册bean定义。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">这一通分析下来，推导出来的<strong style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\">结论</strong>是：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">截止到目前，只有主类自己被注册了bean定义。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">为了证明这一点，把日志级别改为DEBUG，如下图11：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221543106-95640083.png\" alt=\"\"></p>\r\n<p><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">可以看出在源码中，把资源数组进行了debug输出。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">最终输出内容，如下图12：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221550743-190181193.png\" alt=\"\"></p>\r\n<p><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ac39ff;\">发现确实只注册了主类自己，没有其它。</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">和我们分析的一样，哈哈。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">到现在prepareContext已经执行完毕了，接下来该执行的就是refreshContext了。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">熟悉Spring容器的都知道，refresh其实就是容器的启动了。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">因此最后得出一个<strong style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\">结论</strong>，对于“常规”的SpringBoot应用：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">在Spring容器启动前，只有应用的主类自己被注册了bean定义。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">What，are you kidding me？</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">Of course not。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ac39ff;\">那其它的那些bean定义是何时及如何注册的呢？</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">且听下回分解。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">最后来看看主类的bean定义信息，作为一个小小的彩蛋吧。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">如下图13：</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img src=\"https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221602237-1270205211.png\" alt=\"\"></p>\r\n<p><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\">可以看出bean名称符合</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">生成规则</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">，bean定义使用了</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">CGLIB</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">生成了代理。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">bean的一些属性，</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">单例、非抽象、非延迟加载、未明确定义自动装配方式、作为自动装配候选bean，非主要的</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">等等。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">bean定义的实现类是</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">AnnotatedGenericBeanDefinition</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">，可知是通过</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px; color: #ff0000;\">编程方式</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">（而非jar包扫描）注册的bean定义。</span><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><br style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><strong style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">预祝</span></strong><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">，看过本文的人都有所收获。</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; letter-spacing: 2px;\">若能转发一下，则求之不得。</span></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: #ffffff;\">&nbsp;</p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; line-height: 1.5em; text-align: center; background-color: #ffffff;\"><strong style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 14px; color: #ff2941; letter-spacing: normal;\">&gt;&gt;&gt; 品Spring系列文章 &lt;&lt;&lt;</span></strong></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; line-height: 1.5em; text-align: center; background-color: #ffffff;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; color: #ff2941; font-size: 14px; letter-spacing: normal;\">&nbsp;</span></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; line-height: 1.5em; text-align: center; background-color: #ffffff;\"><a style=\"margin: 0px; padding: 0px; color: #0052ff; text-decoration: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); cursor: pointer; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 14px; letter-spacing: normal;\" href=\"http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;mid=2247484224&amp;idx=1&amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;scene=21#wechat_redirect\" target=\"_blank\" data-itemshowtype=\"0\" data-linktype=\"2\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; color: #0052ff; font-size: 14px; letter-spacing: normal;\">品Spring：帝国的基石</span></a></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; line-height: 1.5em; text-align: center; background-color: #ffffff;\"><a style=\"margin: 0px; padding: 0px; color: #0052ff; text-decoration: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); cursor: pointer; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 14px; letter-spacing: normal;\" href=\"http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;mid=2247484229&amp;idx=1&amp;sn=b552914c42963d06306d35f1d8332284&amp;chksm=fc3338b5cb44b1a39d0762b2fd94d8870fcbc520b0713964d9a453d8466d781897707de8cd8f&amp;scene=21#wechat_redirect\" target=\"_blank\" data-itemshowtype=\"0\" data-linktype=\"2\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; color: #0052ff; font-size: 14px; letter-spacing: normal;\">品Spring：bean定义上梁山</span></a></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; line-height: 1.5em; text-align: center; background-color: #ffffff;\"><a style=\"margin: 0px; padding: 0px; color: #0052ff; text-decoration: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); cursor: pointer; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 14px; letter-spacing: normal;\" href=\"http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;mid=2247484244&amp;idx=1&amp;sn=d500b3ed748331687028b78d567222a8&amp;chksm=fc3338a4cb44b1b23f5dd9bef1cc66950a1ded23151a05b38716f4ec46ff960cdda5d8022e8f&amp;scene=21#wechat_redirect\" target=\"_blank\" data-itemshowtype=\"0\" data-linktype=\"2\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; color: #0052ff; font-size: 14px; letter-spacing: normal;\">品Spring：实现bean定义时采用的“先进生产力”</span></a></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; line-height: 1.5em; text-align: center; background-color: #ffffff;\"><a style=\"margin: 0px; padding: 0px; color: #0052ff; text-decoration: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); cursor: pointer; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 14px; letter-spacing: normal;\" href=\"http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;mid=2247484249&amp;idx=1&amp;sn=dfbdca65a2b64b0ac951f90b301e73a0&amp;chksm=fc3338a9cb44b1bfafee072597430dae91d4dd8b4787e4af0896f9ce45b258fd5d3634169a5d&amp;scene=21#wechat_redirect\" target=\"_blank\" data-itemshowtype=\"0\" data-linktype=\"2\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; color: #0052ff; font-size: 14px; letter-spacing: normal;\">品Spring：注解终于“成功上位”</span></a></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; line-height: 1.5em; text-align: center; background-color: #ffffff;\"><a style=\"margin: 0px; padding: 0px; color: #0052ff; text-decoration: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); cursor: pointer; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 14px;\" href=\"http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;mid=2247484259&amp;idx=1&amp;sn=791a5726b9b7bf41e4e64053cfbc7ffa&amp;chksm=fc333893cb44b1851d2052423392551ca9188c4fc0a33f412ddda13af9e0dc6655966a668964&amp;scene=21#wechat_redirect\" target=\"_blank\" data-itemshowtype=\"0\" data-linktype=\"2\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 14px; color: #0052ff;\">品Spring：能工巧匠们对注解的“加持”</span></a></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; line-height: 1.5em; text-align: center; background-color: #ffffff;\"><a style=\"margin: 0px; padding: 0px; color: #0052ff; text-decoration: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); cursor: pointer; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 14px;\" href=\"http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;mid=2247484301&amp;idx=1&amp;sn=a5557c4c285cb07a052238d3de2a2585&amp;chksm=fc33387dcb44b16b487edee0ab4c755de394d19dd4a0acd2532af0e49e95eb7988628e93157b&amp;scene=21#wechat_redirect\" target=\"_blank\" data-itemshowtype=\"0\" data-linktype=\"2\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 14px; color: #0052ff;\">品Spring：SpringBoot和Spring到底有没有本质的不同？</span></a></p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; line-height: 1.5em; text-align: center; background-color: #ffffff;\"><a style=\"margin: 0px; padding: 0px; color: #0052ff; text-decoration: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); cursor: pointer; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 14px;\" href=\"http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;mid=2247484319&amp;idx=1&amp;sn=89d925e6128109444c2ec40111a9f217&amp;chksm=fc33386fcb44b179dcee6ef522e2252420658c0342759a9d6d9795bf90b144f6284c72fe808d&amp;scene=21#wechat_redirect\" target=\"_blank\" data-itemshowtype=\"0\" data-linktype=\"2\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 14px; color: #0052ff;\">品Spring：负责bean定义注册的两个“排头兵”</span></a></p>\r\n<p>&nbsp;</p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: 0.544px; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: #ffffff;\"><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 16px; color: #ac39ff;\"><strong style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\">作者</strong></span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; color: #ff2941; font-size: 15px;\">是工作超过</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 16px; color: #ac39ff;\"><strong style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\">10年</strong></span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; color: #ff2941; font-size: 15px;\">的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。</span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; color: #ac39ff; font-size: 16px;\"><strong style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;\">追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。</strong></span><span style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; font-size: 15px; color: #ff2941;\">下面是公众号和知识星球的二维码，欢迎关注！</span></p>\r\n<p>&nbsp;</p>\r\n<p style=\"margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; clear: both; min-height: 1em; color: #333333; font-family: -apple-system-font, BlinkMacSystemFont, \'Helvetica Neue\', \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei UI\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 17px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: 0.544000029563904px; line-height: 27.2000007629395px; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-align: center; background-color: #ffffff;\"><img style=\"margin: 0px; padding: 0px; height: auto !important; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; width: 134px !important; visibility: visible !important;\" src=\"https://img2018.cnblogs.com/blog/76066/201904/76066-20190419093441100-1622885471.jpg\" alt=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Apple-converted-space\">&nbsp;</span><img class=\"rich_pages\" style=\"margin: 0px; padding: 0px; height: auto !important; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; width: 133px !important; visibility: visible !important;\" src=\"https://img2018.cnblogs.com/blog/76066/201904/76066-20190419132131137-250931220.png\" alt=\"\"></p>\r\n<p>&nbsp;</p>\r\n</div>', '2020-01-01', 0, 0, 0, 1, 2, 1);
INSERT INTO `app01_article` VALUES (5, 'Django+MySQL Dashboard 网页端数据库可视化', '基于 Python 开发语言，用前端 Django 框架，对后端 MySQL 数据进行可视化 web 端维护 ...', '<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\r\n    <h1 id=\"eshopdashboardml---销售预测\">eShopDashboardML - 销售预测</h1>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>ML.NET 版本</th>\r\n<th>API 类型</th>\r\n<th>状态</th>\r\n<th>应用程序类型</th>\r\n<th>数据类型</th>\r\n<th>场景</th>\r\n<th>机器学习任务</th>\r\n<th>算法</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>v1.3.1</td>\r\n<td>动态 API</td>\r\n<td>最新版本</td>\r\n<td>ASP.NET Core Web应用程序和控制台应用程序</td>\r\n<td>SQL Server 和 .csv 文件</td>\r\n<td>销售预测</td>\r\n<td>回归</td>\r\n<td>FastTreeTweedie Regression, Single Spectrum Analysis</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>eShopDashboardML是一个使用<a href=\"https://github.com/dotnet/machinelearning\">ML.NET</a> 进行（每个产品和每个地区）销售预测的Web应用程序。</p>\r\n<h1 id=\"概述\">概述</h1>\r\n<p>这个终端示例应用程序通过展现以下主题着重介绍ML.NET API的用法:</p>\r\n<ol>\r\n<li>如何训练，建立和生成ML模型\r\n<ul>\r\n<li>使用.NET Core实现一个<a href=\"https://github.com/feiyun0112/machinelearning-samples.zh-cn/blob/master/samples/csharp/end-to-end-apps/Regression-SalesForecast/src%5CeShopForecastModelsTrainer\">控制台应用程序</a>。</li>\r\n</ul></li>\r\n<li>如何使用经过训练的ML模型做下个月的销售预测\r\n<ul>\r\n<li>使用<a href=\"https://docs.microsoft.com/aspnet/core/tutorials/razor-pages/\">ASP.NET Core Razor</a>实现一个独立的，单体<a href=\"https://github.com/feiyun0112/machinelearning-samples.zh-cn/blob/master/samples/csharp/end-to-end-apps/Regression-SalesForecast/src%5CeShopDashboard\">Web应用程序</a>。</li>\r\n</ul></li>\r\n</ol>\r\n<p>该应用程序还使用一个SQL Server数据库存储常规产品目录和订单信息，就像许多使用SQL Server的典型Web应用程序一样。在本例中，由于它是一个示例，因此默认情况下使用localdb SQL数据库，因此不需要设置真正的SQL Server。在第一次运行Web应用程序时，将创建localdb数据库并包含示例数据。</p>\r\n<p>如果要使用真正的SQL Server或Azure SQL数据库，只需更改应用程序中的连接字符串即可。</p>\r\n<p>当你运行应用程序时，它会打开一个网页，上面有一个搜索框，上面写着“输入一个产品”。你可以输入任何产品，例如“瓶子”。然后与关键字“瓶子”相关的产品列表将显示在自动完成建议中。选择任何产品后，该产品的销售预测将显示如下。</p>\r\n<p>这是Web应用程序的一个销售预测屏幕截图示例：</p>\r\n<p><img src=\"https://raw.githubusercontent.com/dotnet/machinelearning-samples/master/samples/csharp/end-to-end-apps/Forecasting-Sales/docs/images/eShopDashboard.png\" alt=\"image\"></p>\r\n<h2 id=\"设置\">设置</h2>\r\n<p>了解如何在 Visual Studio 中设置以及对代码的进一步说明：</p>\r\n<ul>\r\n<li><p><a href=\"https://github.com/dotnet/machinelearning-samples/blob/master/samples/csharp/end-to-end-apps/Forecasting-Sales/docs/Setting-up-eShopDashboard-in-Visual-Studio-and-running-it.md\">在 Visual Studio 中设置 eShopDashboard 并运行Web应用程序</a></p></li>\r\n<li><a href=\"https://github.com/dotnet/machinelearning-samples/blob/master/samples/csharp/end-to-end-apps/Forecasting-Sales/docs/Create-and-train-the-models-%5BOptional%5D.md\">创建和训练您的ML模型</a>\r\n<ul>\r\n<li>此步骤是可选的，因为Web应用程序已配置为使用预先训练的模型。 但是，您可以创建自己的训练模型，并将预先训练的模型与您自己的模型交换。</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"ml.net代码简介\">ML.NET代码简介</h2>\r\n<h3 id=\"问题\">问题</h3>\r\n<p>这个问题是基于之前的销售情况围绕地区和产品进行销售预测</p>\r\n<h3 id=\"数据集\">数据集</h3>\r\n<p>为了解决这个问题，您建立了两个独立的ML模型，它们以以下数据集作为输入：</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>数据集</th>\r\n<th>列</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><strong>products stats</strong></td>\r\n<td>next, productId, year, month, units, avg, count, max, min, prev</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><strong>country stats</strong></td>\r\n<td>next, country, year, month, max, min, std, count, sales, med, prev</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><a href=\"https://github.com/dotnet/machinelearning-samples/blob/master/samples/csharp/end-to-end-apps/Forecasting-Sales/docs/Details-of-Dataset.md\">数据集说明</a> - 转到此链接可获取有关数据集的详细信息。</p>\r\n<h3 id=\"ml-任务---回归预测与时间序列预测\">ML 任务 - 回归预测与时间序列预测</h3>\r\n<p>这个示例显示了可用于预测的两种不同的ML任务和算法：</p>\r\n<ul>\r\n<li><strong>回归</strong> 使用 FastTreeTweedie Regression</li>\r\n<li><strong>时间序列</strong> 使用 Single Spectrum Analysis</li>\r\n</ul>\r\n<p><strong>回归</strong> 是一个有监督的机器学习任务，用于从一组相关的特征/变量预测<strong>下一个</strong>期间的值（在本例中是销售预测）。 <strong>回归</strong> 最适合线性数据。</p>\r\n<p><strong>时间序列</strong> 是一种估计技术，可用于预测未来的<strong>多个</strong>周期。<strong>时间序列</strong>在涉及难以区分趋势和模式的非线性数据的情况下很好地工作。</p>\r\n<h3 id=\"解决方案\">解决方案</h3>\r\n<p>为了解决这个问题，首先我们将建立ML模型，同时根据现有数据训练每个模型，评估其有多好，最后使用模型预测销售。</p>\r\n<p>注意<strong>回归</strong>样本实现了两个独立的模型来预测线性数据：</p>\r\n<ul>\r\n<li>下一个周期（月）产品需求预测模型</li>\r\n<li>下一个周期（月）地区销售预测模型</li>\r\n</ul>\r\n<p><strong>时间序列</strong>样本实现产品在未来<strong>两个</strong>周期（月）的需求预测。<strong>时间序列</strong>样本使用与<strong>回归</strong>样本相同的产品，以便您可以比较两种算法的预测。</p>\r\n<p>在学习/研究样本时，您可以选择专注于回归或时间序列。</p>\r\n<p><img src=\"https://raw.githubusercontent.com/dotnet/machinelearning-samples/master/samples/csharp/getting-started/shared_content/modelpipeline.png\" alt=\"Build -> Train -> Evaluate -> Consume\"><br>\r\n)</p>\r\n<h4 id=\"加载数据集\">加载数据集</h4>\r\n<p><strong>回归</strong>和<strong>时间序列</strong>样本均通过使用<strong>TextLoader</strong>加载数据开始。 要使用<strong>TextLoader</strong>，我们必须指定代表数据模式的类的类型。 我们的类类型为<strong>ProductData</strong>。</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\"> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProductData</span>\r\n    {\r\n        <span class=\"hljs-comment\">// The index of column in LoadColumn(int index) should be matched with the position of columns in the underlying data file.</span>\r\n        <span class=\"hljs-comment\">// The next column is used by the Regression algorithm as the Label (e.g. the value that is being predicted by the Regression model).</span>\r\n        [<span class=\"hljs-meta\">LoadColumn(0)</span>]\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> next;\r\n\r\n        [<span class=\"hljs-meta\">LoadColumn(1)</span>]\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">string</span> productId;\r\n\r\n        [<span class=\"hljs-meta\">LoadColumn(2)</span>]\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> year;\r\n\r\n        [<span class=\"hljs-meta\">LoadColumn(3)</span>]\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> month;\r\n\r\n        [<span class=\"hljs-meta\">LoadColumn(4)</span>]\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> units;\r\n\r\n        [<span class=\"hljs-meta\">LoadColumn(5)</span>]\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> avg;\r\n\r\n        [<span class=\"hljs-meta\">LoadColumn(6)</span>]\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> count;\r\n\r\n        [<span class=\"hljs-meta\">LoadColumn(7)</span>]\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> max;\r\n\r\n        [<span class=\"hljs-meta\">LoadColumn(8)</span>]\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> min;\r\n\r\n        [<span class=\"hljs-meta\">LoadColumn(9)</span>]\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> prev;\r\n    }</code></pre>\r\n<p>将数据集加载到<strong>DataView</strong>中。</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\"><span class=\"hljs-keyword\">var</span> trainingDataView = mlContext.Data.LoadFromTextFile&lt;ProductData&gt;(dataPath, hasHeader: <span class=\"hljs-literal\">true</span>, separatorChar:<span class=\"hljs-string\">\',\'</span>);</code></pre>\r\n<p>在接下来的步骤中，我们将构建转换管道，指定要使用的训练器/算法，评估模型并测试其预测。 这是<a href=\"#regression\"><strong>回归</strong></a>和<a href=\"#time-series\"><strong>时间序列</strong></a>示例之间的步骤开始有所不同的地方-本演练的其余部分分别研究了每种算法。</p>\r\n<h3 id=\"回归\">回归</h3>\r\n<h4 id=\"回归-创建管道\">1. 回归: 创建管道</h4>\r\n<p>此步骤说明如何创建稍后用于构建和训练<strong>回归</strong>模型的管道。</p>\r\n<p>具体来说，我们进行以下转换：</p>\r\n<ul>\r\n<li>连接当前特征生成名为<strong>NumFeatures</strong>的新列</li>\r\n<li>使用<a href=\"https://en.wikipedia.org/wiki/One-hot\">独热编码</a>转换<strong>productId</strong></li>\r\n<li>连接所有生成的特征生成名为<strong>Features</strong>的新列</li>\r\n<li>复制<strong>next</strong>列将其重命名为<strong>Label</strong></li>\r\n<li>指定<strong>Fast Tree Tweedie</strong>训练器作为算法应用于模型</li>\r\n</ul>\r\n<p>在设计管道之后，您可以将数据集加载到DataView中，而且此步骤只是配置，DataView是延迟加载，在下一步训练模型之前数据不会被加载。</p>\r\n<p><a href=\"https://github.com/dotnet/machinelearning-samples/blob/master/samples/csharp/end-to-end-apps/Forecasting-Sales/src/eShopForecastModelsTrainer/RegressionTrainer/RegressionProductModelHelper.cs\">建立模型并训练</a></p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\"><span class=\"hljs-keyword\">var</span> trainer = mlContext.Regression.Trainers.FastTreeTweedie(<span class=\"hljs-string\">\"Label\"</span>, <span class=\"hljs-string\">\"Features\"</span>);\r\n\r\n<span class=\"hljs-keyword\">var</span> trainingPipeline = mlContext.Transforms.Concatenate(outputColumnName: <span class=\"hljs-string\">\"NumFeatures\"</span>, <span class=\"hljs-keyword\">nameof</span>(CountryData.year),\r\n                                <span class=\"hljs-keyword\">nameof</span>(CountryData.month), <span class=\"hljs-keyword\">nameof</span>(CountryData.max), <span class=\"hljs-keyword\">nameof</span>(CountryData.min),\r\n                                <span class=\"hljs-keyword\">nameof</span>(CountryData.std), <span class=\"hljs-keyword\">nameof</span>(CountryData.count), <span class=\"hljs-keyword\">nameof</span>(CountryData.sales),\r\n                                <span class=\"hljs-keyword\">nameof</span>(CountryData.med), <span class=\"hljs-keyword\">nameof</span>(CountryData.prev))\r\n                    .Append(mlContext.Transforms.Categorical.OneHotEncoding(outputColumnName: <span class=\"hljs-string\">\"CatFeatures\"</span>, inputColumnName: <span class=\"hljs-keyword\">nameof</span>(CountryData.country)))\r\n                    .Append(mlContext.Transforms.Concatenate(outputColumnName: <span class=\"hljs-string\">\"Features\"</span>, <span class=\"hljs-string\">\"NumFeatures\"</span>, <span class=\"hljs-string\">\"CatFeatures\"</span>))\r\n                    .Append(mlContext.Transforms.CopyColumns(outputColumnName: <span class=\"hljs-string\">\"Label\"</span>, inputColumnName: <span class=\"hljs-keyword\">nameof</span>(CountryData.next)))\r\n                    .Append(trainer);</code></pre>\r\n<h4 id=\"回归-评估模型\">2. 回归: 评估模型</h4>\r\n<p>在本例中，<strong>回归</strong>模型的评估是在使用交叉验证方法训练模型之前执行的，因此您将获得指示模型准确度的指标。</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\"><span class=\"hljs-keyword\">var</span> crossValidationResults = mlContext.Regression.CrossValidate(data:trainingDataView, estimator:trainingPipeline, numberOfFolds: <span class=\"hljs-number\">6</span>, labelColumnName: <span class=\"hljs-string\">\"Label\"</span>);\r\n\r\nConsoleHelper.PrintRegressionFoldsAverageMetrics(trainer.ToString(), crossValidationResults);</code></pre>\r\n<h4 id=\"回归-训练模型\">3. 回归: 训练模型</h4>\r\n<p>在建立管道之后，我们通过使用所选算法拟合或使用训练数据来训练预测<strong>回归</strong>模型。 在该步骤中，模型被建立，训练并作为对象返回：</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\"><span class=\"hljs-keyword\">var</span> model = trainingPipeline.Fit(trainingDataView);</code></pre>\r\n<h4 id=\"回归-保存模型\">4. 回归: 保存模型</h4>\r\n<p>一旦创建和评估了<strong>回归</strong>模型，就可以将它保存到<strong>zip</strong>文件中，任何最终用户的应用程序都可以通过以下代码使用它：</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\"><span class=\"hljs-keyword\">using</span> (<span class=\"hljs-keyword\">var</span> file = File.OpenWrite(outputModelPath))\r\n    mlContext.Model.Save(model, trainingDataView.Schema, file);</code></pre>\r\n<h4 id=\"回归-测试预测\">5. 回归: 测试预测</h4>\r\n<p>从<strong>zip</strong>文件中加载<strong>回归</strong>模型。</p>\r\n<p>本示例使用产品样本数据的最后一个月来预测下个月的单位销售额。</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\">ITransformer trainedModel;\r\n<span class=\"hljs-keyword\">using</span> (<span class=\"hljs-keyword\">var</span> stream = File.OpenRead(outputModelPath))\r\n{\r\n    trainedModel = mlContext.Model.Load(stream,<span class=\"hljs-keyword\">out</span> <span class=\"hljs-keyword\">var</span> modelInputSchema);\r\n}\r\n\r\n<span class=\"hljs-keyword\">var</span> predictionEngine = mlContext.Model.CreatePredictionEngine&lt;CountryData, CountrySalesPrediction&gt;(trainedModel);\r\n\r\nConsole.WriteLine(<span class=\"hljs-string\">\"** Testing Product 1 **\"</span>);\r\n\r\n<span class=\"hljs-comment\">// Build sample data</span>\r\nProductData dataSample = <span class=\"hljs-keyword\">new</span> ProductData()\r\n{\r\n    productId = <span class=\"hljs-string\">\"263\"</span>,\r\n    month = <span class=\"hljs-number\">10</span>,\r\n    year = <span class=\"hljs-number\">2017</span>,\r\n    avg = <span class=\"hljs-number\">91</span>,\r\n    max = <span class=\"hljs-number\">370</span>,\r\n    min = <span class=\"hljs-number\">1</span>,\r\n    count = <span class=\"hljs-number\">10</span>,\r\n    prev = <span class=\"hljs-number\">1675</span>,\r\n    units = <span class=\"hljs-number\">910</span>\r\n};\r\n\r\n<span class=\"hljs-comment\">// Predict the next period/month forecast to the one provided</span>\r\nProductUnitPrediction prediction = predictionEngine.Predict(dataSample);\r\nConsole.WriteLine(<span class=\"hljs-string\">$\"Product: <span class=\"hljs-subst\">{dataSample.productId}</span>, month: <span class=\"hljs-subst\">{dataSample.month + <span class=\"hljs-number\">1</span>}</span>, year: <span class=\"hljs-subst\">{dataSample.year}</span> - Real value (units): 551, Forecast Prediction (units): <span class=\"hljs-subst\">{prediction.Score}</span>\"</span>);</code></pre>\r\n<h3 id=\"时间序列\">时间序列</h3>\r\n<h4 id=\"时间序列-创建管道\">1. 时间序列: 创建管道</h4>\r\n<p>此步骤说明如何创建稍后用于训练<strong>时间序列</strong>模型的管道。</p>\r\n<p>具体来说，<strong>Single Spectrum Analysis (SSA)</strong>训练器是所使用的算法。此算法使用以下参数：</p>\r\n<ul>\r\n<li><strong>outputColumnName</strong>: 这是将用于存储预测的列的名称。列必须是<strong>single</strong>类型的向量。在后面的步骤中，我们定义了一个名为<strong>ProductUnitTimeSeriesPrediction</strong>的类，该类包含此输出列。</li>\r\n<li><strong>inputColumnName</strong>: 这是正在预测的列的名称。该列包含时间序列中时间戳处的值，并且必须是<strong>single</strong>类型。在我们的示例中，我们正在预测产品<strong>数量</strong>。</li>\r\n<li><strong>windowSize</strong>: 该参数用于定义滑动时间窗，该滑动时间窗用于将时间序列数据分解为趋势、季节或噪声分量。通常，应该从窗口大小开始，窗口大小代表场景中的业务周期。在我们的示例中，产品数据基于12个月的周期，因此我们将选择一个窗口大小为12的倍数。</li>\r\n<li><strong>seriesLength</strong>:</li>\r\n<li><strong>trainSize</strong>:</li>\r\n<li><strong>horizon</strong>: 此参数指示要预测的时段数。在我们的示例中，我们指定了2，以表示将预测未来2个月的产品数量。</li>\r\n<li><strong>confidenceLevel</strong>: 此参数表示预测值落在指定间隔范围内的可能性。通常，.95是一个可接受的起点。</li>\r\n<li><strong>confidenceLowerBoundColumn</strong>: 这是用于存储每个预测值的<strong>下限</strong>置信区间的列的名称。<strong>ProductUnitTimeSeriesPrediction</strong>类也包含此输出列。</li>\r\n<li><strong>confidenceUpperBoundColumn</strong>: 这是将用于存储每个预测值的<strong>上限</strong>置信区间的列的名称。<strong>ProductUnitTimeSeriesPrediction</strong>类也包含此输出列。</li>\r\n</ul>\r\n<p>具体来说，我们在管道中增加了以下训练器：</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\"><span class=\"hljs-comment\">// Create and add the forecast estimator to the pipeline.</span>\r\nIEstimator&lt;ITransformer&gt; forecastEstimator = mlContext.Forecasting.ForecastBySsa(\r\n    outputColumnName: <span class=\"hljs-keyword\">nameof</span>(ProductUnitTimeSeriesPrediction.ForecastedProductUnits),\r\n    inputColumnName: <span class=\"hljs-keyword\">nameof</span>(ProductData.units),\r\n    windowSize: <span class=\"hljs-number\">3</span>,\r\n    seriesLength: productDataSeriesLength,\r\n    trainSize: productDataSeriesLength,\r\n    horizon: <span class=\"hljs-number\">2</span>,\r\n    confidenceLevel: <span class=\"hljs-number\">0.95</span>f,\r\n    confidenceLowerBoundColumn: <span class=\"hljs-keyword\">nameof</span>(ProductUnitTimeSeriesPrediction.ConfidenceLowerBound),\r\n    confidenceUpperBoundColumn: <span class=\"hljs-keyword\">nameof</span>(ProductUnitTimeSeriesPrediction.ConfidenceUpperBound));</code></pre>\r\n<h4 id=\"时间序列-训练模型\">2. 时间序列: 训练模型</h4>\r\n<p>在训练<strong>时间序列</strong>模型之前，我们首先必须筛选加载的数据集，以选择将用于预测销售的特定产品的数据序列。</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\"><span class=\"hljs-keyword\">var</span> productId = <span class=\"hljs-number\">988</span>;\r\nIDataView productDataView = mlContext.Data.FilterRowsByColumn(allProductsDataView, <span class=\"hljs-keyword\">nameof</span>(ProductData.productId), productId, productId + <span class=\"hljs-number\">1</span>);</code></pre>\r\n<p>接下来，我们使用指定产品的数据系列来训练模型。</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\"><span class=\"hljs-comment\">// Train the forecasting model for the specified product\'s data series.</span>\r\nITransformer forecastTransformer = forecastEstimator.Fit(productDataView);</code></pre>\r\n<h4 id=\"时间序列-保存模型\">3. 时间序列: 保存模型</h4>\r\n<p>要保存模型，我们首先必须创建<strong>TimeSeriesPredictionEngine</strong>用于获取预测和保存模型。</p>\r\n<p>使用<strong>CheckPoint</strong>方法保存<strong>时间序列</strong>模型，该方法将模型保存到任何最终用户应用程序都可以使用的<strong>zip</strong>文件中：</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\"><span class=\"hljs-comment\">// Create the forecast engine used for creating predictions.</span>\r\nTimeSeriesPredictionEngine&lt;ProductData, ProductUnitTimeSeriesPrediction&gt; forecastEngine = forecastTransformer.CreateTimeSeriesEngine&lt;ProductData, ProductUnitTimeSeriesPrediction&gt;(mlContext);\r\n\r\n<span class=\"hljs-comment\">// Save the forecasting model so that it can be loaded within an end-user app.</span>\r\nforecastEngine.CheckPoint(mlContext, outputModelPath);</code></pre>\r\n<p>您可能会注意到这与上面的<strong>回归</strong>示例不同，后者使用<strong>保存</strong>方法来保存模型。<strong>时间序列</strong>是不同的，因为它要求在进行预测时用新的观测值不断更新模型的状态。因此，存在<strong>CheckPoint</strong>方法来更新和保存模型状态。这将在本示例后面的步骤中进一步详细说明。现在，请记住<strong>CheckPoint</strong>用于保存<strong>时间序列</strong>模型。</p>\r\n<h4 id=\"时间序列-测试预测\">4. 时间序列: 测试预测</h4>\r\n<p>要获得预测，请从<strong>zip</strong>文件加载<strong>时间序列</strong>模型，并创建新的<strong>TimeSeriesPredictionEngine</strong>。在这之后，我们可以得到一个预测。</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\"><span class=\"hljs-comment\">// Load the forecast engine that has been previously saved.</span>\r\nITransformer forecaster;\r\n<span class=\"hljs-keyword\">using</span> (<span class=\"hljs-keyword\">var</span> file = File.OpenRead(outputModelPath))\r\n{\r\n    forecaster = mlContext.Model.Load(file, <span class=\"hljs-keyword\">out</span> DataViewSchema schema);\r\n}\r\n\r\n<span class=\"hljs-comment\">// We must create a new prediction engine from the persisted model.</span>\r\nTimeSeriesPredictionEngine&lt;ProductData, ProductUnitTimeSeriesPrediction&gt; forecastEngine = forecastTransformer.CreateTimeSeriesEngine&lt;ProductData, ProductUnitTimeSeriesPrediction&gt;(mlContext); forecastEngine = forecaster.CreateTimeSeriesEngine&lt;ProductData, ProductUnitTimeSeriesPrediction&gt;(mlContext);\r\n\r\nProductUnitTimeSeriesPrediction originalSalesPrediction = forecastEngine.Predict();</code></pre>\r\n<p>创建<strong>TimeSeriesPredictionEngine</strong>时指定的<strong>ProductUnitTimeSeriesPrediction</strong>类型用于存储预测结果：</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\">   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProductUnitTimeSeriesPrediction</span>\r\n    {\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span>[] ForecastedProductUnits { <span class=\"hljs-keyword\">get</span>; <span class=\"hljs-keyword\">set</span>; }\r\n\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span>[] ConfidenceLowerBound { <span class=\"hljs-keyword\">get</span>; <span class=\"hljs-keyword\">set</span>; }\r\n\r\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span>[] ConfidenceUpperBound { <span class=\"hljs-keyword\">get</span>; <span class=\"hljs-keyword\">set</span>; }\r\n    }</code></pre>\r\n<p>记住，当我们使用<strong>ForecastBySsa</strong>方法创建SSA Forecasting Trainer时，我们提供了以下参数值：</p>\r\n<ul>\r\n<li><strong>horizon</strong>: 2</li>\r\n<li><strong>confidenceLevel</strong>: .95f</li>\r\n</ul>\r\n<p>因此，当我们使用加载的模型调用<strong>Predict</strong>方法时，<strong>ForecastedProductUnits</strong>向量将包含<strong>两个</strong>预测值。同样，<strong>ConfidenceLowerBound</strong>和<strong>ConfidenceUpperBound</strong>向量将分别包含基于指定的<strong>confidenceLevel</strong>的<strong>两个</strong>值。</p>\r\n<p>您可能注意到<strong>Predict</strong>方法有几个重载，它们接受以下参数：</p>\r\n<ul>\r\n<li><strong>horizon</strong></li>\r\n<li><strong>confidenceLevel</strong></li>\r\n<li><strong>ProductData example</strong></li>\r\n</ul>\r\n<p>这允许您在每次进行预测时为<strong>horizon</strong>和<strong>confidenceLevel</strong>指定新值。此外，还可以使用<strong>example</strong>参数为时间序列传递新的观察到的<strong>ProductData</strong>值。</p>\r\n<p>当使用新的观察到的<strong>ProductData</strong>值调用<strong>Predict</strong>时，这将用时间序列中的这些数据点更新模型状态。然后，您可以选择通过调用<strong>CheckPoint</strong>方法将此模型保存到磁盘。</p>\r\n<p>这在我们的示例中也可以看到：</p>\r\n<pre class=\"csharp\"><code class=\"hljs cs\">ProductUnitTimeSeriesPrediction updatedSalesPrediction = forecastEngine.Predict(newProductData, horizon: <span class=\"hljs-number\">1</span>);\r\n\r\n <span class=\"hljs-comment\">// Save the updated forecasting model.</span>\r\n forecastEngine.CheckPoint(mlContext, outputModelPath);</code></pre>\r\n<h2 id=\"引用\">引用</h2>\r\n<p>eShopDashboardML数据集是基于<strong>UCI</strong>(<a href=\"http://archive.ics.uci.edu/ml/datasets/online+retail\" class=\"uri\">http://archive.ics.uci.edu/ml/datasets/online+retail</a>) 的一个公共在线零售数据集</p>\r\n<blockquote>\r\n<p>Daqing Chen, Sai Liang Sain, 和 Kun Guo, 在线零售业的数据挖掘: 基于RFM模型的数据挖掘客户细分案例研究, 数据库营销与客户战略管理杂志, Vol. 19, No. 3, pp. 197â€“208, 2012 (印刷前在线发布: 27 August 2012. doi: 10.1057/dbm.2012.17).</p>\r\n</blockquote>\r\n\r\n</div>', '2020-01-01', 0, 1, 0, 2, 3, 1);
INSERT INTO `app01_article` VALUES (6, 'mybatis中collection association优化使用及多参数传递', 'mybatis都会用，但要优雅的用就不是那么容易了 今天就简单举例，抛砖引玉，供大家探讨 1.主表 对应的java实体类如下（自动生成的代码，省略get set） 注意：JsonIgnoreProperties请忽略，这是解决对象间循环依赖在json序列化时出错的，不在本次内容中 2.从表 对应的j ...', '<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\r\n    <h1 id=\"目录\">目录</h1>\r\n<ul>\r\n<li><a href=\"#为什么要使用异常\">为什么要使用异常</a></li>\r\n<li><a href=\"#异常基本定义\">异常基本定义</a></li>\r\n<li><a href=\"#异常体系\">异常体系</a></li>\r\n<li><a href=\"#初识异常\">初识异常</a></li>\r\n<li><a href=\"#异常和错误\">异常和错误</a></li>\r\n<li><a href=\"#异常的处理方式\">异常的处理方式</a></li>\r\n<li><a href=\"#不负责任的throws\">\"不负责任\"的throws</a></li>\r\n<li><a href=\"#纠结的finally\">纠结的finally</a></li>\r\n<li><a href=\"#throw--jre也使用的关键字\">throw : JRE也使用的关键字</a></li>\r\n<li><a href=\"#异常调用链\">异常调用链</a></li>\r\n<li><a href=\"#自定义异常\">自定义异常</a></li>\r\n<li><a href=\"#异常的注意事项\">异常的注意事项</a></li>\r\n<li><a href=\"#当finally遇上return\">当finally遇上return</a></li>\r\n<li><a href=\"#java异常常见面试题\">JAVA异常常见面试题</a></li>\r\n<li><a href=\"#参考文章\">参考文章</a></li>\r\n<li><a href=\"#微信公众号\">微信公众号</a>\r\n<ul>\r\n<li><a href=\"#java技术江湖\">Java技术江湖</a></li>\r\n<li><a href=\"#个人公众号：黄小斜\">个人公众号：黄小斜</a></li>\r\n</ul></li>\r\n</ul>\r\n<hr>\r\n<h2 id=\"java异常\">- Java异常</h2>\r\n<p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>\r\n<blockquote>\r\n<p>https://github.com/h2pl/Java-Tutorial</p>\r\n</blockquote>\r\n<p>喜欢的话麻烦点下Star哈</p>\r\n<p>文章首发于我的个人博客：</p>\r\n<blockquote>\r\n<p>www.how2playlife.com</p>\r\n</blockquote>\r\n<p>本文是微信公众号【Java技术江湖】的《夯实Java基础系列博文》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。<br>\r\n该系列博文会告诉你如何从入门到进阶，一步步地学习Java基础知识，并上手进行实战，接着了解每个Java知识点背后的实现原理，更完整地了解整个Java技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。</p>\r\n<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>\r\n<!-- more -->\r\n<h2 id=\"为什么要使用异常\">为什么要使用异常</h2>\r\n<blockquote>\r\n<p>首先我们可以明确一点就是异常的处理机制可以确保我们程序的健壮性，提高系统可用率。虽然我们不是特别喜欢看到它，但是我们不能不承认它的地位，作用。</p>\r\n</blockquote>\r\n<p>在没有异常机制的时候我们是这样处理的：通过函数的返回值来判断是否发生了异常（这个返回值通常是已经约定好了的），调用该函数的程序负责检查并且分析返回值。虽然可以解决异常问题，但是这样做存在几个缺陷：</p>\r\n<blockquote>\r\n<p>1、 容易混淆。如果约定返回值为-11111时表示出现异常，那么当程序最后的计算结果真的为-1111呢？</p>\r\n<p>2、 代码可读性差。将异常处理代码和程序代码混淆在一起将会降低代码的可读性。</p>\r\n<p>3、 由调用函数来分析异常，这要求程序员对库函数有很深的了解。</p>\r\n</blockquote>\r\n<p>在OO中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它。</p>\r\n<p>而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。</p>\r\n<p>这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。（摘自《Think in java 》）。</p>\r\n<p>该部分内容选自http://www.cnblogs.com/chenssy/p/3438130.html</p>\r\n<h2 id=\"异常基本定义\">异常基本定义</h2>\r\n<blockquote>\r\n<p>在《Think in java》中是这样定义异常的：异常情形是指阻止当前方法或者作用域继续执行的问题。在这里一定要明确一点：异常代码某种程度的错误，尽管Java有异常处理机制，但是我们不能以“正常”的眼光来看待异常，异常处理机制的原因就是告诉你：这里可能会或者已经产生了错误，您的程序出现了不正常的情况，可能会导致程序失败！</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>那么什么时候才会出现异常呢？只有在你当前的环境下程序无法正常运行下去，也就是说程序已经无法来正确解决问题了，这时它所就会从当前环境中跳出，并抛出异常。抛出异常后，它首先会做几件事。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>首先，它会使用new创建一个异常对象，然后在产生异常的位置终止程序，并且从当前环境中弹出对异常对象的引用，这时。异常处理机制就会接管程序，并开始寻找一个恰当的地方来继续执行程序，这个恰当的地方就是异常处理程序。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>总的来说异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。</p>\r\n</blockquote>\r\n<h2 id=\"异常体系\">异常体系</h2>\r\n<p>[外链图片转存失败(img-KNxcBTK0-1569073569353)(https://images0.cnblogs.com/blog/381060/201311/22185952-834d92bc2bfe498f9a33414cc7a2c8a4.png)]</p>\r\n<p>从上面这幅图可以看出，Throwable是java语言中所有错误和异常的超类（万物即可抛）。它有两个子类：Error、Exception。</p>\r\n<p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。</p>\r\n<p>Throwable又派生出Error类和Exception类。</p>\r\n<p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p>\r\n<p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。</p>\r\n<p>总体上我们根据Javac对异常的处理要求，将异常类分为2类。</p>\r\n<blockquote>\r\n<p>非检查异常（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>检查异常（checked exception）：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。</p>\r\n</blockquote>\r\n<p>需要明确的是：检查和非检查是对于javac来说的，这样就很好理解和区分了。</p>\r\n<p>这部分内容摘自http://www.importnew.com/26613.html</p>\r\n<h2 id=\"初识异常\">初识异常</h2>\r\n<p>异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么他的所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成的了异常追踪栈。</p>\r\n<p>异常最先发生的地方，叫做异常抛出点。</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 异常 </span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span> <span class=\"hljs-params\">(String [] args )</span>\r\n    </span>{\r\n        System . out. println( <span class=\"hljs-string\">\"----欢迎使用命令行除法计算器----\"</span> ) ;\r\n        CMDCalculate ();\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CMDCalculate</span> <span class=\"hljs-params\">()</span>\r\n    </span>{\r\n        Scanner scan = <span class=\"hljs-keyword\">new</span> Scanner ( System. in );\r\n        <span class=\"hljs-keyword\">int</span> num1 = scan .nextInt () ;\r\n        <span class=\"hljs-keyword\">int</span> num2 = scan .nextInt () ;\r\n        <span class=\"hljs-keyword\">int</span> result = devide (num1 , num2 ) ;\r\n        System . out. println( <span class=\"hljs-string\">\"result:\"</span> + result) ;\r\n        scan .close () ;\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">devide</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> num1, <span class=\"hljs-keyword\">int</span> num2 )</span></span>{\r\n        <span class=\"hljs-keyword\">return</span> num1 / num2 ;\r\n    }\r\n\r\n<span class=\"hljs-comment\">//    ----欢迎使用命令行除法计算器----</span>\r\n<span class=\"hljs-comment\">//            1</span>\r\n<span class=\"hljs-comment\">//            0</span>\r\n<span class=\"hljs-comment\">//    Exception in thread \"main\" java.lang.ArithmeticException: / by zero</span>\r\n<span class=\"hljs-comment\">//    at com.javase.异常.异常.devide(异常.java:24)</span>\r\n<span class=\"hljs-comment\">//    at com.javase.异常.异常.CMDCalculate(异常.java:19)</span>\r\n<span class=\"hljs-comment\">//    at com.javase.异常.异常.main(异常.java:12)</span></code></pre>\r\n<p>​</p>\r\n<pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span>  ----欢迎使用命令行除法计算器----\r\n<span class=\"hljs-regexp\">//</span>    r\r\n<span class=\"hljs-regexp\">//</span>    Exception <span class=\"hljs-keyword\">in</span> thread <span class=\"hljs-string\">\"main\"</span> java.util.InputMismatchException\r\n<span class=\"hljs-regexp\">//</span>    at java.util.Scanner.throwFor(Scanner.java:<span class=\"hljs-number\">864</span>)\r\n<span class=\"hljs-regexp\">//</span>    at java.util.Scanner.<span class=\"hljs-keyword\">next</span>(Scanner.java:<span class=\"hljs-number\">1485</span>)\r\n<span class=\"hljs-regexp\">//</span>    at java.util.Scanner.nextInt(Scanner.java:<span class=\"hljs-number\">2117</span>)\r\n<span class=\"hljs-regexp\">//</span>    at java.util.Scanner.nextInt(Scanner.java:<span class=\"hljs-number\">2076</span>)\r\n<span class=\"hljs-regexp\">//</span>    at com.javase.异常.异常.CMDCalculate(异常.java:<span class=\"hljs-number\">17</span>)\r\n<span class=\"hljs-regexp\">//</span>    at com.javase.异常.异常.main(异常.java:<span class=\"hljs-number\">12</span>)</code></pre>\r\n<p>[外链图片转存失败(img-9rqUQJQj-1569073569354)(http://incdn1.b0.upaiyun.com/2017/09/0b3e4ca2f4cf8d7116c7ad354940601f.png)]</p>\r\n<p>从上面的例子可以看出，当devide函数发生除0异常时，devide函数将抛出ArithmeticException异常，因此调用他的CMDCalculate函数也无法正常完成，因此也发送异常，而CMDCalculate的caller——main 因为CMDCalculate抛出异常，也发生了异常，这样一直向调用栈的栈底回溯。</p>\r\n<p>这种行为叫做异常的冒泡，异常的冒泡是为了在当前发生异常的函数或者这个函数的caller中找到最近的异常处理程序。由于这个例子中没有使用任何异常处理机制，因此异常最终由main函数抛给JRE，导致程序终止。</p>\r\n<blockquote>\r\n<p>上面的代码不使用异常处理机制，也可以顺利编译，因为2个异常都是非检查异常。但是下面的例子就必须使用异常处理机制，因为异常是检查异常。</p>\r\n</blockquote>\r\n<p>代码中我选择使用throws声明异常，让函数的调用者去处理可能发生的异常。但是为什么只throws了IOException呢？因为FileNotFoundException是IOException的子类，在处理范围内。</p>\r\n<h2 id=\"异常和错误\">异常和错误</h2>\r\n<p>下面看一个例子</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">//错误即error一般指jvm无法处理的错误</span>\r\n<span class=\"hljs-comment\">//异常是Java定义的用于简化错误处理流程和定位错误的一种工具。</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 错误和错误 </span>{\r\n    Error error = <span class=\"hljs-keyword\">new</span> Error();\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\r\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error();\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//下面这四个异常或者错误有着不同的处理方法</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">error1</span> <span class=\"hljs-params\">()</span></span>{\r\n        <span class=\"hljs-comment\">//编译期要求必须处理，因为这个异常是最顶层异常，包括了检查异常，必须要处理</span>\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Throwable();\r\n        } <span class=\"hljs-keyword\">catch</span> (Throwable throwable) {\r\n            throwable.printStackTrace();\r\n        }\r\n    }\r\n    <span class=\"hljs-comment\">//Exception也必须处理。否则报错，因为检查异常都继承自exception，所以默认需要捕捉。</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">error2</span> <span class=\"hljs-params\">()</span></span>{\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Exception();\r\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//error可以不处理，编译不报错,原因是虚拟机根本无法处理，所以啥都不用做</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">error3</span> <span class=\"hljs-params\">()</span></span>{\r\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error();\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//runtimeexception众所周知编译不会报错</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">error4</span> <span class=\"hljs-params\">()</span></span>{\r\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException();\r\n    }\r\n<span class=\"hljs-comment\">//    Exception in thread \"main\" java.lang.Error</span>\r\n<span class=\"hljs-comment\">//    at com.javase.异常.错误.main(错误.java:11)</span>\r\n\r\n}</code></pre>\r\n<h2 id=\"异常的处理方式\">异常的处理方式</h2>\r\n<p>在编写代码处理异常时，对于检查异常，有2种不同的处理方式：</p>\r\n<blockquote>\r\n<p>使用try…catch…finally语句块处理它。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>或者，在函数签名中使用throws 声明交给函数调用者caller去解决。</p>\r\n</blockquote>\r\n<p>下面看几个具体的例子，包括error，exception和throwable</p>\r\n<p>上面的例子是运行时异常，不需要显示捕获。<br>\r\n下面这个例子是可检查异常需，要显示捕获或者抛出。</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Test</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testException</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException\r\n</span>{\r\n    <span class=\"hljs-comment\">//FileInputStream的构造函数会抛出FileNotFoundException</span>\r\n    FileInputStream fileIn = <span class=\"hljs-keyword\">new</span> FileInputStream(<span class=\"hljs-string\">\"E:\\\\a.txt\"</span>);\r\n\r\n    <span class=\"hljs-keyword\">int</span> word;\r\n    <span class=\"hljs-comment\">//read方法会抛出IOException</span>\r\n    <span class=\"hljs-keyword\">while</span>((word =  fileIn.read())!=-<span class=\"hljs-number\">1</span>)\r\n    {\r\n        System.out.print((<span class=\"hljs-keyword\">char</span>)word);\r\n    }\r\n    <span class=\"hljs-comment\">//close方法会抛出IOException</span>\r\n    fileIn.close();\r\n}</code></pre>\r\n<p>一般情况下的处理方式 try catch finally</p>\r\n<pre><code class=\"hljs coffeescript\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 异常处理方式 {</span>\r\n\r\n@Test\r\npublic void main() {\r\n    <span class=\"hljs-keyword\">try</span>{\r\n        <span class=\"hljs-regexp\">//</span><span class=\"hljs-keyword\">try</span>块中放可能发生异常的代码。\r\n        InputStream inputStream = <span class=\"hljs-keyword\">new</span> FileInputStream(<span class=\"hljs-string\">\"a.txt\"</span>);\r\n\r\n        <span class=\"hljs-regexp\">//</span>如果执行完<span class=\"hljs-keyword\">try</span>且不发生异常，则接着去执行<span class=\"hljs-keyword\">finally</span>块和<span class=\"hljs-keyword\">finally</span>后面的代码（如果有的话）。\r\n        int i = <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-regexp\">//</span>如果发生异常，则尝试去匹配<span class=\"hljs-keyword\">catch</span>块。\r\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> SQLException();\r\n        <span class=\"hljs-regexp\">//</span>使用<span class=\"hljs-number\">1.8</span>jdk同时捕获多个异常，runtimeexception也可以捕获。只是捕获后虚拟机也无法处理，所以不建议捕获。\r\n    }<span class=\"hljs-keyword\">catch</span>(SQLException | IOException | ArrayIndexOutOfBoundsException exception){\r\n        System.out.println(exception.getMessage());\r\n        <span class=\"hljs-regexp\">//</span>每一个<span class=\"hljs-keyword\">catch</span>块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个<span class=\"hljs-keyword\">catch</span>中。\r\n\r\n        <span class=\"hljs-regexp\">//</span><span class=\"hljs-keyword\">catch</span>后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个<span class=\"hljs-keyword\">catch</span>块来处理异常。\r\n\r\n        <span class=\"hljs-regexp\">//</span>在<span class=\"hljs-keyword\">catch</span>块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个<span class=\"hljs-keyword\">catch</span>块中的局部变量，其它块不能访问。\r\n\r\n        <span class=\"hljs-regexp\">//</span>如果当前<span class=\"hljs-keyword\">try</span>块中发生的异常在后续的所有<span class=\"hljs-keyword\">catch</span>中都没捕获到，则先去执行<span class=\"hljs-keyword\">finally</span>，然后到这个函数的外部caller中去匹配异常处理器。\r\n\r\n        <span class=\"hljs-regexp\">//</span>如果<span class=\"hljs-keyword\">try</span>中没有发生异常，则所有的<span class=\"hljs-keyword\">catch</span>块将被忽略。\r\n\r\n    }<span class=\"hljs-keyword\">catch</span>(Exception exception){\r\n        System.out.println(exception.getMessage());\r\n        <span class=\"hljs-regexp\">//</span>...\r\n    }<span class=\"hljs-keyword\">finally</span>{\r\n        <span class=\"hljs-regexp\">//</span><span class=\"hljs-keyword\">finally</span>块通常是可选的。\r\n        <span class=\"hljs-regexp\">//</span>无论异常是否发生，异常是否匹配被处理，<span class=\"hljs-keyword\">finally</span>都会执行。\r\n\r\n        <span class=\"hljs-regexp\">//</span><span class=\"hljs-keyword\">finally</span>主要做一些清理工作，如流的关闭，数据库连接的关闭等。\r\n    }</code></pre>\r\n<p>一个try至少要跟一个catch或者finally</p>\r\n<pre><code class=\"hljs coffeescript\">    <span class=\"hljs-keyword\">try</span> {\r\n        int i = <span class=\"hljs-number\">1</span>;\r\n    }<span class=\"hljs-keyword\">finally</span> {\r\n        <span class=\"hljs-regexp\">//</span>一个<span class=\"hljs-keyword\">try</span>至少要有一个<span class=\"hljs-keyword\">catch</span>块，否则， 至少要有<span class=\"hljs-number\">1</span>个<span class=\"hljs-keyword\">finally</span>块。但是<span class=\"hljs-keyword\">finally</span>不是用来处理异常的，<span class=\"hljs-keyword\">finally</span>不会捕获异常。\r\n    }\r\n}</code></pre>\r\n<p>异常出现时该方法后面的代码不会运行，即使异常已经被捕获。这里举出一个奇特的例子，在catch里再次使用try catch finally</p>\r\n<pre><code class=\"hljs cs\">@<span class=\"hljs-function\">Test\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{\r\n    <span class=\"hljs-keyword\">try</span> {\r\n        throwE();\r\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"我前面抛出异常了\"</span>);\r\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"我不会执行了\"</span>);\r\n    } <span class=\"hljs-keyword\">catch</span> (StringIndexOutOfBoundsException e) {\r\n        System.<span class=\"hljs-keyword\">out</span>.println(e.getCause());\r\n    }<span class=\"hljs-keyword\">catch</span> (Exception ex) {\r\n    <span class=\"hljs-comment\">//在catch块中仍然可以使用try catch finally</span>\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Exception();\r\n        }<span class=\"hljs-keyword\">catch</span> (Exception ee) {\r\n            \r\n        }<span class=\"hljs-keyword\">finally</span> {\r\n            System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"我所在的catch块没有执行，我也不会执行的\"</span>);\r\n        }\r\n    }\r\n}\r\n<span class=\"hljs-comment\">//在方法声明中抛出的异常必须由调用方法处理或者继续往上抛，</span>\r\n<span class=\"hljs-comment\">// 当抛到jre时由于无法处理终止程序</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">throwE</span> (<span class=\"hljs-params\"></span>)</span>{\r\n<span class=\"hljs-comment\">//        Socket socket = new Socket(\"127.0.0.1\", 80);</span>\r\n\r\n        <span class=\"hljs-comment\">//手动抛出异常时，不会报错，但是调用该方法的方法需要处理这个异常，否则会出错。</span>\r\n<span class=\"hljs-comment\">//        java.lang.StringIndexOutOfBoundsException</span>\r\n<span class=\"hljs-comment\">//        at com.javase.异常.异常处理方式.throwE(异常处理方式.java:75)</span>\r\n<span class=\"hljs-comment\">//        at com.javase.异常.异常处理方式.test(异常处理方式.java:62)</span>\r\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> StringIndexOutOfBoundsException();\r\n    }</code></pre>\r\n<p>其实有的语言在遇到异常后仍然可以继续运行</p>\r\n<blockquote>\r\n<p>有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handling（恢复式异常处理模式 ）</p>\r\n<p>而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handling（终结式异常处理模式）</p>\r\n</blockquote>\r\n<h2 id=\"不负责任的throws\">\"不负责任\"的throws</h2>\r\n<p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p>\r\n<p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> ExceptionType1 , ExceptionType2 ,ExceptionTypeN\r\n</span>{ \r\n     <span class=\"hljs-comment\">//foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。</span>\r\n}</code></pre>\r\n<h2 id=\"纠结的finally\">纠结的finally</h2>\r\n<p>finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。</p>\r\n<p>良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源。</p>\r\n<p>需要注意的地方:</p>\r\n<p>1、finally块没有处理异常的能力。处理异常的只能是catch块。</p>\r\n<p>2、在同一try…catch…finally块中 ，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有catch块匹配，则先执行finally，然后去外面的调用者中寻找合适的catch块。</p>\r\n<p>3、在同一try…catch…finally块中 ，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：首先执行finally块，然后去外围调用者中寻找合适的catch块。</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">finally</span>使用 </span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalAccessException();\r\n        }<span class=\"hljs-keyword\">catch</span> (IllegalAccessException e) {\r\n            <span class=\"hljs-comment\">// throw new Throwable();</span>\r\n            <span class=\"hljs-comment\">//此时如果再抛异常，finally无法执行，只能报错。</span>\r\n            <span class=\"hljs-comment\">//finally无论何时都会执行</span>\r\n            <span class=\"hljs-comment\">//除非我显示调用。此时finally才不会执行</span>\r\n            System.exit(<span class=\"hljs-number\">0</span>);\r\n\r\n        }<span class=\"hljs-keyword\">finally</span> {\r\n            System.out.println(<span class=\"hljs-string\">\"算你狠\"</span>);\r\n        }\r\n    }\r\n}</code></pre>\r\n<h2 id=\"throw-jre也使用的关键字\">throw : JRE也使用的关键字</h2>\r\n<p>throw exceptionObject</p>\r\n<p>程序员也可以通过throw语句手动显式的抛出一个异常。throw语句的后面必须是一个异常对象。</p>\r\n<p>throw 语句必须写在函数中，执行throw 语句的地方就是一个异常抛出点，==它和由JRE自动形成的异常抛出点没有任何差别。==</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(User user)</span>\r\n</span>{\r\n      <span class=\"hljs-keyword\">if</span>(user  == <span class=\"hljs-keyword\">null</span>) \r\n          <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"User对象为空\"</span>);\r\n      <span class=\"hljs-comment\">//......</span>\r\n \r\n}</code></pre>\r\n<p>后面开始的大部分内容都摘自http://www.cnblogs.com/lulipro/p/7504267.html</p>\r\n<p>该文章写的十分细致到位，令人钦佩，是我目前为之看到关于异常最详尽的文章，可以说是站在巨人的肩膀上了。</p>\r\n<h2 id=\"异常调用链\">异常调用链</h2>\r\n<p>异常的链化</p>\r\n<p>在一些大型的，模块化的软件开发中，一旦一个地方发生异常，则如骨牌效应一样，将导致一连串的异常。假设B模块完成自己的逻辑需要调用A模块的方法，如果A模块发生异常，则B也将不能完成而发生异常。</p>\r\n<p>==但是B在抛出异常时，会将A的异常信息掩盖掉，这将使得异常的根源信息丢失。异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。==</p>\r\n<blockquote>\r\n<p>异常链化:以一个异常对象为参数构造新的异常对象。新的异对象将包含先前异常的信息。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫他根源异常（cause）。</p>\r\n</blockquote>\r\n<p>查看Throwable类源码，可以发现里面有一个Throwable字段cause，就是它保存了构造时传递的根源异常参数。这种设计和链表的结点类设计如出一辙，因此形成链也是自然的了。</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Throwable</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\r\n    <span class=\"hljs-keyword\">private</span> Throwable cause = <span class=\"hljs-keyword\">this</span>;\r\n \r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Throwable</span><span class=\"hljs-params\">(String message, Throwable cause)</span> </span>{\r\n        fillInStackTrace();\r\n        detailMessage = message;\r\n        <span class=\"hljs-keyword\">this</span>.cause = cause;\r\n    }\r\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Throwable</span><span class=\"hljs-params\">(Throwable cause)</span> </span>{\r\n        fillInStackTrace();\r\n        detailMessage = (cause==<span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-keyword\">null</span> : cause.toString());\r\n        <span class=\"hljs-keyword\">this</span>.cause = cause;\r\n    }\r\n \r\n    <span class=\"hljs-comment\">//........</span>\r\n}</code></pre>\r\n<p>下面看一个比较实在的异常链例子哈</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 异常链 </span>{\r\n    <span class=\"hljs-meta\">@Test</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n        C();\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">A</span> <span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>;\r\n            i = i / <span class=\"hljs-number\">0</span>;\r\n            <span class=\"hljs-comment\">//当我注释掉这行代码并使用B方法抛出一个error时，运行结果如下</span>\r\n<span class=\"hljs-comment\">//            四月 27, 2018 10:12:30 下午 org.junit.platform.launcher.core.ServiceLoaderTestEngineRegistry loadTestEngines</span>\r\n<span class=\"hljs-comment\">//            信息: Discovered TestEngines with IDs: [junit-jupiter]</span>\r\n<span class=\"hljs-comment\">//            java.lang.Error: B也犯了个错误</span>\r\n<span class=\"hljs-comment\">//            at com.javase.异常.异常链.B(异常链.java:33)</span>\r\n<span class=\"hljs-comment\">//            at com.javase.异常.异常链.C(异常链.java:38)</span>\r\n<span class=\"hljs-comment\">//            at com.javase.异常.异常链.test(异常链.java:13)</span>\r\n<span class=\"hljs-comment\">//            at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span>\r\n<span class=\"hljs-comment\">//            Caused by: java.lang.Error</span>\r\n<span class=\"hljs-comment\">//            at com.javase.异常.异常链.B(异常链.java:29)</span>\r\n\r\n        }<span class=\"hljs-keyword\">catch</span> (ArithmeticException e) {\r\n            <span class=\"hljs-comment\">//这里通过throwable类的构造方法将最底层的异常重新包装并抛出，此时注入了A方法的信息。最后打印栈信息时可以看到caused by</span>\r\n            A方法的异常。\r\n            <span class=\"hljs-comment\">//如果直接抛出，栈信息打印结果只能看到上层方法的错误信息，不能看到其实是A发生了错误。</span>\r\n            <span class=\"hljs-comment\">//所以需要包装并抛出</span>\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Exception(<span class=\"hljs-string\">\"A方法计算错误\"</span>, e);\r\n        }\r\n\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">B</span> <span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception,Error </span>{\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-comment\">//接收到A的异常，</span>\r\n            A();\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error();\r\n        }<span class=\"hljs-keyword\">catch</span> (Exception e) {\r\n            <span class=\"hljs-keyword\">throw</span> e;\r\n        }<span class=\"hljs-keyword\">catch</span> (Error error) {\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error(<span class=\"hljs-string\">\"B也犯了个错误\"</span>, error);\r\n        }\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">C</span> <span class=\"hljs-params\">()</span> </span>{\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            B();\r\n        }<span class=\"hljs-keyword\">catch</span> (Exception | Error e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n\r\n    <span class=\"hljs-comment\">//最后结果</span>\r\n<span class=\"hljs-comment\">//    java.lang.Exception: A方法计算错误</span>\r\n<span class=\"hljs-comment\">//    at com.javase.异常.异常链.A(异常链.java:18)</span>\r\n<span class=\"hljs-comment\">//    at com.javase.异常.异常链.B(异常链.java:24)</span>\r\n<span class=\"hljs-comment\">//    at com.javase.异常.异常链.C(异常链.java:31)</span>\r\n<span class=\"hljs-comment\">//    at com.javase.异常.异常链.test(异常链.java:11)</span>\r\n<span class=\"hljs-comment\">//    省略</span>\r\n<span class=\"hljs-comment\">//    Caused by: java.lang.ArithmeticException: / by zero</span>\r\n<span class=\"hljs-comment\">//    at com.javase.异常.异常链.A(异常链.java:16)</span>\r\n<span class=\"hljs-comment\">//            ... 31 more</span>\r\n}</code></pre>\r\n<h2 id=\"自定义异常\">自定义异常</h2>\r\n<p>如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。</p>\r\n<p>按照国际惯例，自定义的异常应该总是包含如下的构造函数：</p>\r\n<p>一个无参构造函数<br>\r\n一个带有String参数的构造函数，并传递给父类的构造函数。<br>\r\n一个带有String参数和Throwable参数，并都传递给父类构造函数<br>\r\n一个带有Throwable 参数的构造函数，并传递给父类的构造函数。<br>\r\n下面是IOException类的完整源代码，可以借鉴。</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">IOException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Exception</span>\r\n</span>{\r\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> serialVersionUID = <span class=\"hljs-number\">7818375828146090155L</span>;\r\n \r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">IOException</span><span class=\"hljs-params\">()</span>\r\n    </span>{\r\n        <span class=\"hljs-keyword\">super</span>();\r\n    }\r\n \r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">IOException</span><span class=\"hljs-params\">(String message)</span>\r\n    </span>{\r\n        <span class=\"hljs-keyword\">super</span>(message);\r\n    }\r\n \r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">IOException</span><span class=\"hljs-params\">(String message, Throwable cause)</span>\r\n    </span>{\r\n        <span class=\"hljs-keyword\">super</span>(message, cause);\r\n    }\r\n \r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">IOException</span><span class=\"hljs-params\">(Throwable cause)</span>\r\n    </span>{\r\n        <span class=\"hljs-keyword\">super</span>(cause);\r\n    }\r\n}</code></pre>\r\n<h2 id=\"异常的注意事项\">异常的注意事项</h2>\r\n<p>异常的注意事项</p>\r\n<blockquote>\r\n<p>当子类重写父类的带有 throws声明的函数时，其throws声明的异常必须在父类异常的可控范围内——用于处理父类的throws方法的异常处理器，必须也适用于子类的这个带throws方法 。这是为了支持多态。</p>\r\n<p>例如，父类方法throws 的是2个异常，子类就不能throws 3个及以上的异常。父类throws IOException，子类就必须throws IOException或者IOException的子类。</p>\r\n</blockquote>\r\n<p>至于为什么？我想，也许下面的例子可以说明。</p>\r\n<pre><code class=\"hljs scala\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>\r\n{\r\n    public void start() <span class=\"hljs-keyword\">throws</span> <span class=\"hljs-type\">IOException</span>\r\n    {\r\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">IOException</span>();\r\n    }\r\n}\r\n \r\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Son</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>\r\n{\r\n    public void start() <span class=\"hljs-keyword\">throws</span> <span class=\"hljs-type\">Exception</span>\r\n    {\r\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">SQLException</span>();\r\n    }\r\n}</code></pre>\r\n<p>/**********************假设上面的代码是允许的（实质是错误的）***********************/</p>\r\n<pre><code class=\"hljs groovy\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span>\r\n{</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> main(String[] args)\r\n    {\r\n        Father[] objs = <span class=\"hljs-keyword\">new</span> Father[<span class=\"hljs-number\">2</span>];\r\n        objs[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-keyword\">new</span> Father();\r\n        objs[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-keyword\">new</span> Son();\r\n \r\n        <span class=\"hljs-keyword\">for</span>(Father <span class=\"hljs-string\">obj:</span>objs)\r\n        {\r\n        <span class=\"hljs-comment\">//因为Son类抛出的实质是SQLException，而IOException无法处理它。</span>\r\n        <span class=\"hljs-comment\">//那么这里的try。。catch就不能处理Son中的异常。</span>\r\n        <span class=\"hljs-comment\">//多态就不能实现了。</span>\r\n            <span class=\"hljs-keyword\">try</span> {\r\n                 obj.start();\r\n            }<span class=\"hljs-keyword\">catch</span>(IOException)\r\n            {\r\n                 <span class=\"hljs-comment\">//处理IOException</span>\r\n            }\r\n         }\r\n   }\r\n}</code></pre>\r\n<p>==Java的异常执行流程是线程独立的，线程之间没有影响==</p>\r\n<blockquote>\r\n<p>Java程序可以是多线程的。每一个线程都是一个独立的执行流，独立的函数调用栈。如果程序只有一个线程，那么没有被任何代码处理的异常 会导致程序终止。如果是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。</p>\r\n<p>也就是说，Java中的异常是线程独立的，线程的问题应该由线程自己来解决，而不要委托到外部，也不会直接影响到其它线程的执行。</p>\r\n</blockquote>\r\n<p>下面看一个例子</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 多线程的异常 </span>{\r\n    <span class=\"hljs-meta\">@Test</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n        go();\r\n    }\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">go</span> <span class=\"hljs-params\">()</span> </span>{\r\n        ExecutorService executorService = Executors.newFixedThreadPool(<span class=\"hljs-number\">3</span>);\r\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt;= <span class=\"hljs-number\">2</span>;i ++) {\r\n            <span class=\"hljs-keyword\">int</span> finalI = i;\r\n            <span class=\"hljs-keyword\">try</span> {\r\n                Thread.sleep(<span class=\"hljs-number\">2000</span>);\r\n            } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            executorService.execute(<span class=\"hljs-keyword\">new</span> Runnable() {\r\n                <span class=\"hljs-meta\">@Override</span>\r\n                <span class=\"hljs-comment\">//每个线程抛出异常时并不会影响其他线程的继续执行</span>\r\n                <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\r\n                    <span class=\"hljs-keyword\">try</span> {\r\n                        System.out.println(<span class=\"hljs-string\">\"start thread\"</span> + finalI);\r\n                        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Exception();\r\n                    }<span class=\"hljs-keyword\">catch</span> (Exception e) {\r\n                        System.out.println(<span class=\"hljs-string\">\"thread\"</span> + finalI + <span class=\"hljs-string\">\" go wrong\"</span>);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n<span class=\"hljs-comment\">//        结果：</span>\r\n<span class=\"hljs-comment\">//        start thread0</span>\r\n<span class=\"hljs-comment\">//        thread0 go wrong</span>\r\n<span class=\"hljs-comment\">//        start thread1</span>\r\n<span class=\"hljs-comment\">//        thread1 go wrong</span>\r\n<span class=\"hljs-comment\">//        start thread2</span>\r\n<span class=\"hljs-comment\">//        thread2 go wrong</span>\r\n    }\r\n}</code></pre>\r\n<h2 id=\"当finally遇上return\">当finally遇上return</h2>\r\n<p>首先一个不容易理解的事实：</p>\r\n<p>在 try块中即便有return，break，continue等改变执行流的语句，finally也会执行。</p>\r\n<pre><code class=\"hljs cs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>)\r\n</span>{\r\n    <span class=\"hljs-keyword\">int</span> re = bar();\r\n    System.<span class=\"hljs-keyword\">out</span>.println(re);\r\n}\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>) \r\n</span>{\r\n    <span class=\"hljs-keyword\">try</span>{\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">5</span>;\r\n    } <span class=\"hljs-keyword\">finally</span>{\r\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"finally\"</span>);\r\n    }\r\n}\r\n<span class=\"hljs-comment\">/*输出：\r\nfinally\r\n*/</span></code></pre>\r\n<p>很多人面对这个问题时，总是在归纳执行的顺序和规律，不过我觉得还是很难理解。我自己总结了一个方法。用如下GIF图说明。</p>\r\n<p>[外链图片转存失败(img-SceF4t85-1569073569354)(http://incdn1.b0.upaiyun.com/2017/09/0471c2805ebd5a463211ced478eaf7f8.gif)]</p>\r\n<p>也就是说：try…catch…finally中的return 只要能执行，就都执行了，他们共同向同一个内存地址（假设地址是0×80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。那么，按照这个思想，下面的这个例子也就不难理解了。</p>\r\n<p>finally中的return 会覆盖 try 或者catch中的返回值。</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span>\r\n    </span>{\r\n        <span class=\"hljs-keyword\">int</span> result;\r\n \r\n        result  =  foo();\r\n        System.out.println(result);     <span class=\"hljs-comment\">/////////2</span>\r\n \r\n        result = bar();\r\n        System.out.println(result);    <span class=\"hljs-comment\">/////////2</span>\r\n    }\r\n \r\n    <span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"finally\"</span>)\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>\r\n    </span>{\r\n        trz{\r\n            <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">5</span> / <span class=\"hljs-number\">0</span>;\r\n        } <span class=\"hljs-keyword\">catch</span> (Exception e){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\r\n        } <span class=\"hljs-keyword\">finally</span>{\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;\r\n        }\r\n \r\n    }\r\n \r\n    <span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"finally\"</span>)\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">()</span>\r\n    </span>{\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\r\n        }<span class=\"hljs-keyword\">finally</span> {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;\r\n        }\r\n    }</code></pre>\r\n<p>finally中的return会抑制（消灭）前面try或者catch块中的异常</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestException</span>\r\n</span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span>\r\n    </span>{\r\n        <span class=\"hljs-keyword\">int</span> result;\r\n        <span class=\"hljs-keyword\">try</span>{\r\n            result = foo();\r\n            System.out.println(result);           <span class=\"hljs-comment\">//输出100</span>\r\n        } <span class=\"hljs-keyword\">catch</span> (Exception e){\r\n            System.out.println(e.getMessage());    <span class=\"hljs-comment\">//没有捕获到异常</span>\r\n        }\r\n \r\n        <span class=\"hljs-keyword\">try</span>{\r\n            result  = bar();\r\n            System.out.println(result);           <span class=\"hljs-comment\">//输出100</span>\r\n        } <span class=\"hljs-keyword\">catch</span> (Exception e){\r\n            System.out.println(e.getMessage());    <span class=\"hljs-comment\">//没有捕获到异常</span>\r\n        }\r\n    }\r\n \r\n    <span class=\"hljs-comment\">//catch中的异常被抑制</span>\r\n    <span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"finally\"</span>)\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception\r\n    </span>{\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">5</span>/<span class=\"hljs-number\">0</span>;\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\r\n        }<span class=\"hljs-keyword\">catch</span>(ArithmeticException amExp) {\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Exception(<span class=\"hljs-string\">\"我将被忽略，因为下面的finally中使用了return\"</span>);\r\n        }<span class=\"hljs-keyword\">finally</span> {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">100</span>;\r\n        }\r\n    }\r\n \r\n    <span class=\"hljs-comment\">//try中的异常被抑制</span>\r\n    <span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"finally\"</span>)\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception\r\n    </span>{\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">5</span>/<span class=\"hljs-number\">0</span>;\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\r\n        }<span class=\"hljs-keyword\">finally</span> {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">100</span>;\r\n        }\r\n    }\r\n}</code></pre>\r\n<p>finally中的异常会覆盖（消灭）前面try或者catch中的异常</p>\r\n<pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestException</span>\r\n</span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span>\r\n    </span>{\r\n        <span class=\"hljs-keyword\">int</span> result;\r\n        <span class=\"hljs-keyword\">try</span>{\r\n            result = foo();\r\n        } <span class=\"hljs-keyword\">catch</span> (Exception e){\r\n            System.out.println(e.getMessage());    <span class=\"hljs-comment\">//输出：我是finaly中的Exception</span>\r\n        }\r\n \r\n        <span class=\"hljs-keyword\">try</span>{\r\n            result  = bar();\r\n        } <span class=\"hljs-keyword\">catch</span> (Exception e){\r\n            System.out.println(e.getMessage());    <span class=\"hljs-comment\">//输出：我是finaly中的Exception</span>\r\n        }\r\n    }\r\n \r\n    <span class=\"hljs-comment\">//catch中的异常被抑制</span>\r\n    <span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"finally\"</span>)\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception\r\n    </span>{\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">5</span>/<span class=\"hljs-number\">0</span>;\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\r\n        }<span class=\"hljs-keyword\">catch</span>(ArithmeticException amExp) {\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Exception(<span class=\"hljs-string\">\"我将被忽略，因为下面的finally中抛出了新的异常\"</span>);\r\n        }<span class=\"hljs-keyword\">finally</span> {\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Exception(<span class=\"hljs-string\">\"我是finaly中的Exception\"</span>);\r\n        }\r\n    }\r\n \r\n    <span class=\"hljs-comment\">//try中的异常被抑制</span>\r\n    <span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"finally\"</span>)\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception\r\n    </span>{\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">5</span>/<span class=\"hljs-number\">0</span>;\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\r\n        }<span class=\"hljs-keyword\">finally</span> {\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Exception(<span class=\"hljs-string\">\"我是finaly中的Exception\"</span>);\r\n        }\r\n \r\n    }\r\n}</code></pre>\r\n<p>上面的3个例子都异于常人的编码思维，因此我建议：</p>\r\n<blockquote>\r\n<p>不要在fianlly中使用return。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>不要在finally中抛出异常。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>减轻finally的任务，不要在finally中做一些其它的事情，finally块仅仅用来释放资源是最合适的。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>将尽量将所有的return写在函数的最后面，而不是try … catch … finally中。</p>\r\n</blockquote>\r\n<h2 id=\"java异常常见面试题\">JAVA异常常见面试题</h2>\r\n<p>　　下面是我个人总结的在Java和J2EE开发者在面试中经常被问到的有关Exception和Error的知识。在分享我的回答的时候，我也给这些问题作了快速修订，并且提供源码以便深入理解。我总结了各种难度的问题，适合新手码农和高级Java码农。如果你遇到了我列表中没有的问题，并且这个问题非常好，请在下面评论中分享出来。你也可以在评论中分享你面试时答错的情况。</p>\r\n<p><strong>1) Java中什么是Exception?</strong><br>\r\n　　这个问题经常在第一次问有关异常的时候或者是面试菜鸟的时候问。我从来没见过面高级或者资深工程师的时候有人问这玩意，但是对于菜鸟，是很愿意问这个的。简单来说，异常是Java传达给你的系统和程序错误的方式。在java中，异常功能是通过实现比如Throwable，Exception，RuntimeException之类的类，然后还有一些处理异常时候的关键字，比如throw，throws，try，catch，finally之类的。&nbsp;所有的异常都是通过Throwable衍生出来的。Throwable把错误进一步划分为&nbsp;java.lang.Exception<br>\r\n和 java.lang.Error.&nbsp; java.lang.Error 用来处理系统错误，例如java.lang.StackOverFlowError 之类的。然后&nbsp;Exception用来处理程序错误，请求的资源不可用等等。</p>\r\n<p><strong>2) Java中的检查型异常和非检查型异常有什么区别？</strong></p>\r\n<p>　　这又是一个非常流行的Java异常面试题，会出现在各种层次的Java面试中。检查型异常和非检查型异常的主要区别在于其处理方式。检查型异常需要使用try, catch和finally关键字在编译期进行处理，否则会出现编译器会报错。对于非检查型异常则不需要这样做。Java中所有继承自java.lang.Exception类的异常都是检查型异常，所有继承自RuntimeException的异常都被称为非检查型异常。</p>\r\n<p><strong>3) Java中的NullPointerException和ArrayIndexOutOfBoundException之间有什么相同之处？</strong></p>\r\n<p>　　在Java异常面试中这并不是一个很流行的问题，但会出现在不同层次的初学者面试中，用来测试应聘者对检查型异常和非检查型异常的概念是否熟悉。顺便说一下，该题的答案是，这两个异常都是非检查型异常，都继承自RuntimeException。该问题可能会引出另一个问题，即Java和C的数组有什么不同之处，因为C里面的数组是没有大小限制的，绝对不会抛出ArrayIndexOutOfBoundException。</p>\r\n<p><strong>4)在Java异常处理的过程中，你遵循的那些最好的实践是什么？</strong></p>\r\n<p>　　这个问题在面试技术经理是非常常见的一个问题。因为异常处理在项目设计中是非常关键的，所以精通异常处理是十分必要的。异常处理有很多最佳实践，下面列举集中，它们提高你代码的健壮性和灵活性：</p>\r\n<p>　　1) 调用方法的时候返回布尔值来代替返回null，这样可以&nbsp;NullPointerException。由于空指针是java异常里最恶心的异常</p>\r\n<p>　　2) catch块里别不写代码。空catch块是异常处理里的错误事件，因为它只是捕获了异常，却没有任何处理或者提示。通常你起码要打印出异常信息，当然你最好根据需求对异常信息进行处理。</p>\r\n<p>　　3)能抛受控异常（checked Exception）就尽量不抛受非控异常(checked Exception)。通过去掉重复的异常处理代码，可以提高代码的可读性。</p>\r\n<p>　　4) 绝对不要让你的数据库相关异常显示到客户端。由于绝大多数数据库和SQLException异常都是受控异常，在Java中，你应该在DAO层把异常信息处理，然后返回处理过的能让用户看懂并根据异常提示信息改正操作的异常信息。</p>\r\n<p>　　5) 在Java中，一定要在数据库连接，数据库查询，流处理后，在finally块中调用close()方法。</p>\r\n<p><strong>5) 既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常?</strong></p>\r\n<p>　　这是一个有争议的问题，在回答该问题时你应当小心。虽然他们肯定愿意听到你的观点，但其实他们最感兴趣的还是有说服力的理由。我认为其中一个理由是，存在检查型异常是一个设计上的决定，受到了诸如C++等比Java更早编程语言设计经验的影响。绝大多数检查型异常位于java.io包内，这是合乎情理的，因为在你请求了不存在的系统资源的时候，一段强壮的程序必须能够优雅的处理这种情况。通过把IOException声明为检查型异常，Java 确保了你能够优雅的对异常进行处理。另一个可能的理由是，可以使用catch或finally来确保数量受限的系统资源（比如文件描述符）在你使用后尽早得到释放。&nbsp;Joshua<br>\r\nBloch编写的&nbsp;<a href=\"http://www.amazon.com/dp/0321356683/?tag=javamysqlanta-20\">Effective Java 一书</a>&nbsp;中多处涉及到了该话题，值得一读。</p>\r\n<p><strong>6) &nbsp;throw 和 throws这两个关键字在java中有什么不同?</strong></p>\r\n<p>　　一个java初学者应该掌握的面试问题。&nbsp;throw 和 throws乍看起来是很相似的尤其是在你还是一个java初学者的时候。尽管他们看起来相似，都是在处理异常时候使用到的。但在代码里的使用方法和用到的地方是不同的。throws总是出现在一个函数头中，用来标明该成员函数可能抛出的各种异常, 你也可以申明未检查的异常，但这不是编译器强制的。如果方法抛出了异常那么调用这个方法的时候就需要将这个异常处理。另一个关键字&nbsp; throw 是用来抛出任意异常的，按照语法你可以抛出任意 Throwable&nbsp;(i.e. Throwable<br>\r\n或任何Throwable的衍生类) , throw可以中断程序运行，因此可以用来代替return . 最常见的例子是用 throw 在一个空方法中需要return的地方抛出 UnSupportedOperationException 代码如下 :</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>123</th>\r\n<th><code>private``static</code> <code>void</code> <code>show() {``throw``new</code> <code>UnsupportedOperationException(``\"Notyet implemented\"``);``}</code></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n</tbody>\r\n</table>\r\n<p>　　可以看下这篇&nbsp;<a href=\"http://javarevisited.blogspot.com/2012/02/difference-between-throw-and-throws-in.html\">文章</a>查看这两个关键字在java中更多的差异 。</p>\r\n<p><strong>7) 什么是“异常链”?</strong></p>\r\n<p>　　“异常链”是Java中非常流行的异常处理概念，是指在进行一个异常处理时抛出了另外一个异常，由此产生了一个异常链条。该技术大多用于将“ 受检查异常” （ checked exception）封装成为“非受检查异常”（unchecked exception)或者RuntimeException。顺便说一下，如果因为因为异常你决定抛出一个新的异常，你一定要包含原有的异常，这样，处理程序才可以通过getCause()和initCause()方法来访问异常最终的根源。</p>\r\n<p><strong>) 你曾经自定义实现过异常吗？怎么写的?</strong></p>\r\n<p>　　很显然，我们绝大多数都写过自定义或者业务异常，像AccountNotFoundException。在面试过程中询问这个Java异常问题的主要原因是去发现你如何使用这个特性的。这可以更准确和精致的去处理异常，当然这也跟你选择checked 还是unchecked exception息息相关。通过为每一个特定的情况创建一个特定的异常，你就为调用者更好的处理异常提供了更好的选择。相比通用异常（general exception)，我更倾向更为精确的异常。大量的创建自定义异常会增加项目class的个数，因此，在自定义异常和通用异常之间维持一个平衡是成功的关键。</p>\r\n<p><strong>9) JDK7中对异常处理做了什么改变？</strong></p>\r\n<p>　　这是最近新出的Java异常处理的面试题。JDK7中对错误(Error)和异常(Exception)处理主要新增加了2个特性，一是在一个catch块中可以出来多个异常，就像原来用多个catch块一样。另一个是自动化资源管理(ARM), 也称为try-with-resource块。这2个特性都可以在处理异常时减少代码量，同时提高代码的可读性。对于这些特性了解，不仅帮助开发者写出更好的异常处理的代码，也让你在面试中显的更突出。我推荐大家读一下Java 7攻略，这样可以更深入的了解这2个非常有用的特性。</p>\r\n<p><strong>10) 你遇到过 OutOfMemoryError 错误嘛？你是怎么搞定的？</strong></p>\r\n<p>　　这个面试题会在面试高级程序员的时候用，面试官想知道你是怎么处理这个危险的OutOfMemoryError错误的。必须承认的是，不管你做什么项目，你都会碰到这个问题。所以你要是说没遇到过，面试官肯定不会买账。要是你对这个问题不熟悉，甚至就是没碰到过，而你又有3、4年的Java经验了，那么准备好处理这个问题吧。在回答这个问题的同时，你也可以借机向面试秀一下你处理内存泄露、调优和调试方面的牛逼技能。我发现掌握这些技术的人都能给面试官留下深刻的印象。</p>\r\n<p><strong>11) 如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗？</strong></p>\r\n<p>　　这个问题也可以换个方式问：“如果在try或者finally的代码块中调用了System.exit()，结果会是怎样”。了解finally块是怎么执行的，即使是try里面已经使用了return返回结果的情况，对了解Java的异常处理都非常有价值。只有在try里面是有System.exit(0)来退出JVM的情况下finally块中的代码才不会执行。</p>\r\n<p><strong>12)Java中final,finalize,finally关键字的区别</strong></p>\r\n<p>　　这是一个经典的Java面试题了。我的一个朋友为Morgan Stanley招电信方面的核心Java开发人员的时候就问过这个问题。final和finally是Java的关键字，而finalize则是方法。final关键字在创建不可变的类的时候非常有用，只是声明这个类是final的。而finalize()方法则是垃圾回收器在回收一个对象前调用，但也Java规范里面没有保证这个方法一定会被调用。finally关键字是唯一一个和这篇文章讨论到的异常处理相关的关键字。在你的产品代码中，在关闭连接和资源文件的是时候都必须要用到finally块。</p>\r\n<h2 id=\"参考文章\">参考文章</h2>\r\n<p>https://www.xuebuyuan.com/3248044.html<br>\r\nhttps://www.jianshu.com/p/49d2c3975c56<br>\r\nhttp://c.biancheng.net/view/1038.html<br>\r\nhttps://blog.csdn.net/Lisiluan/article/details/88745820<br>\r\nhttps://blog.csdn.net/michaelgo/article/details/82790253</p>\r\n<h2 id=\"微信公众号\">微信公众号</h2>\r\n<h3 id=\"java技术江湖\">Java技术江湖</h3>\r\n<p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p>\r\n<p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源，关注公众号后，后台回复关键字 <strong>“Java”</strong> 即可免费无套路获取。</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1092007/201909/1092007-20190928124544119-702226147.jpg\" alt=\"我的公众号\"></p>\r\n<h3 id=\"个人公众号黄小斜\">个人公众号：黄小斜</h3>\r\n<p>作者是 985 硕士，蚂蚁金服 JAVA 工程师，专注于 JAVA 后端技术栈：SpringBoot、MySQL、分布式、中间件、微服务，同时也懂点投资理财，偶尔讲点算法和计算机理论基础，坚持学习和写作，相信终身学习的力量！</p>\r\n<p><strong>程序员3T技术学习资源：</strong> 一些程序员学习技术的资源大礼包，关注公众号后，后台回复关键字 <strong>“资料”</strong> 即可免费无套路获取。</p>\r\n<p><img src=\"https://img2018.cnblogs.com/blog/1092007/201909/1092007-20190928124544324-808940399.jpg\"></p>\r\n\r\n</div>', '2020-01-01', 0, 0, 1, 2, 3, 1);
INSERT INTO `app01_article` VALUES (7, '200行代码实现Mini ASP.NET Core', '前言 在学习ASP.NET Core源码过程中，偶然看见蒋金楠老师的ASP.NET Core框架揭秘，不到200行代码实现了ASP.NET Core Mini框架，针对框架本质进行了讲解，受益匪浅，本文结合ASP.NET Core Mini框架讲述ASP.NET Core核心。 微软官网关于ASP. ...', '<div id=\"cnblogs_post_body\" class=\"blogpost-body \">\r\n    <p><span style=\"color: #0000ff;\"><strong>专用集成电路</strong></span>（<strong><span style=\"color: #ff0000;\">ASIC</span></strong>，Application Specific Integrated Circuit）：是为某种专门用途而设计的集成电路。在用量不大的情况下，具有成本高、设计和制造的周期长。（全定制）</p>\r\n<p>&nbsp;</p>\r\n<p><strong><span style=\"color: #0000ff;\">可编程逻辑器件</span></strong>（<strong><span style=\"color: #ff0000;\">PLD</span></strong>，Programmable Logic Device）：PLD 是做为一种通用集成电路产生的，他的逻辑功能按照用户对器件编程来确定。一般的 PLD 的集成度很高，足以满足设计一般的数字系统的需要。这样就可以由设计人员自行编程而把一个数字系统“集成”在一片 PLD 上，制作成“片上系统”（<strong><span style=\"color: #ff0000;\">SoC</span></strong>，System&nbsp;on Chip），而不必去请芯片制造厂商设计和制作专用的集成电路芯片了。</p>\r\n<p>&nbsp;</p>\r\n<p>目前生产和使用的 PLD&nbsp;产品主要有<strong><span style=\"color: #3366ff;\">可编程逻辑阵列（<span style=\"color: #ff0000;\">PLA</span>，Programmable Logic Array）、可编程阵列逻辑（<span style=\"color: #ff0000;\">PAL</span>，Programmable Array Logic）和通用阵列逻辑（<span style=\"color: #ff0000;\">GAL</span>，Generic Array Logic）、</span><span style=\"color: #0000ff;\">可擦除的可编程逻辑器件（<span style=\"color: #ff0000;\">EPLD</span>，Erasable Programmable&nbsp;Logic Device）、复杂的可编程逻辑器件（<span style=\"color: #ff0000;\">CPLD</span>，Complex Programmable Logic Device）和现场可编程门阵列（<span style=\"color: #ff0000;\">FPGA</span>，Field Programmable Gate Array）</span></strong>等几种类型。其中，PLA、PAL&nbsp;和 GAL&nbsp;称为低密度 PLD（一般在千门以下），EPLD、CPLD&nbsp;和 FPGA&nbsp;称为高密度 PLD。（半定制）</p>\r\n<p>　　PLD 最初使用的编程单元为熔丝或反熔丝（采用熔丝工艺的器件不能改写），后来改为 CMOS&nbsp;工艺，于是编程单元也就变成了叠栅 MOS&nbsp;管了。</p>\r\n<p>　　PLD&nbsp;编程的开发系统主要由由硬件和软件两部分组成。</p>\r\n<p>&nbsp;</p>\r\n<p><span style=\"color: #0000ff;\"><strong>一、PLA　</strong></span>　</p>\r\n<p>　　PLD&nbsp;最早的产品是 PLA，它出现于 20&nbsp;世纪 70&nbsp;年代的后期。如 PLA&nbsp;编程之后的基本电路结构如下所示：</p>\r\n<p><img style=\"display: block; margin-left: auto; margin-right: auto;\" src=\"https://img2018.cnblogs.com/blog/1442352/201909/1442352-20190928111843244-2086358985.png\" alt=\"\"></p>\r\n<p>　　这里，OE\' = 0。此时：</p>\r\n<p>　　　　Y<sub>3</sub> = ABCD +A\'B\'C\'D\'</p>\r\n<p>　　　　Y<sub>2</sub> = AC + BD</p>\r\n<p>　　　　Y<sub>1</sub> = A ⊕&nbsp;B</p>\r\n<p>　　　　Y<sub>0</sub> = C ⊙&nbsp;D</p>\r\n<p>　　这里，介绍一下 PLD&nbsp;中门电路的惯用画法：</p>\r\n<p><img style=\"display: block; margin-left: auto; margin-right: auto;\" src=\"https://img2018.cnblogs.com/blog/1442352/201909/1442352-20190928112012263-1579839588.png\" alt=\"\"></p>\r\n<p>　　以上为组合逻辑型 PLA，不包含触发器，只能用于设计组合逻辑电路。另外，还有包含触发器的用于设计时序逻辑电路的时序逻辑型 PLA。如下所示：</p>\r\n<p><img style=\"display: block; margin-left: auto; margin-right: auto;\" src=\"https://img2018.cnblogs.com/blog/1442352/201909/1442352-20190928132349888-513964620.png\" alt=\"\"></p>\r\n<p>&nbsp;　　总结 PLA：虽然今天已经很少使用 PLA 了，但是之后所出现的 PLD&nbsp;器件的基本原理都源于 PLA，由 PLA&nbsp;发展、演化而来的。此外， PLA&nbsp;作为一种电路结构形式，也仍然可以用于集成电路内部的结构设计当中。</p>\r\n<p>&nbsp;</p>\r\n<p><span style=\"color: #0000ff;\"><strong>二、PAL</strong></span></p>\r\n<p>　　PAL&nbsp;器件由<span style=\"color: #0000ff;\">可编程的与逻辑阵列、固定的或逻辑阵列和输出电路</span>三部分组成。在尚未编程之前，与逻辑阵列的所有交叉点上均有熔丝接通。编程时将有用的熔丝保留，将无用的熔丝熔断，即得到所需的电路。PAL 编程之后的基本电路结构如下所示：</p>\r\n<p><img style=\"display: block; margin-left: auto; margin-right: auto;\" src=\"https://img2018.cnblogs.com/blog/1442352/201909/1442352-20190928132820071-1939825345.png\" alt=\"\"></p>\r\n<p>　　这里：</p>\r\n<p><img style=\"display: block; margin-left: auto; margin-right: auto;\" src=\"https://img2018.cnblogs.com/blog/1442352/201909/1442352-20190928133235413-235133503.png\" alt=\"\"></p>\r\n<p>&nbsp;</p>\r\n<p><strong>三、GAL</strong></p>\r\n<p><strong>　　</strong>GAL 采用了<span style=\"color: #0000ff;\">电可擦除的 CMOS（E<sup>2</sup>CMOS）<span style=\"color: #000000;\">工艺</span></span>制作，可以用电压信号擦除并可重新编程。（以上两种无法改写，以下四种都是可擦除重写的）</p>\r\n<p>　　GAL&nbsp;的基本结构仍为与 -&nbsp;或阵列，不同的是，它的输出端新增加了<span style=\"color: #0000ff;\">可编程的输出逻辑宏单元 OLMC</span>（Output Logic Macro Cell），通过编程可以将 OLMC&nbsp;设置成不同的工作状态，所以具有较强的通用性。</p>\r\n<p>&nbsp;</p>\r\n<p><strong><strong>四、EPLD</strong></strong></p>\r\n<p><strong><strong>　</strong></strong>　EPLD 是从 GAL&nbsp;演变而来的。EPLD 采用了<span style=\"color: #0000ff;\"> CMOS</span>（低功耗、高噪声容限）和<span style=\"color: #0000ff;\"> UVEPROM</span>（可靠性高、可以改写、集成度高、造价便宜）工艺制作。</p>\r\n<p>&nbsp;</p>\r\n<p><strong>五、CPLD</strong></p>\r\n<p><strong>　　</strong>CPLD&nbsp;是从 EPLD&nbsp;演变而来的。CPLD&nbsp;大多采用了 <span style=\"color: #0000ff;\">E<sup>2</sup>CMOS</span>&nbsp;工艺制作。</p>\r\n<p>&nbsp;</p>\r\n<p><strong><strong>六、FPGA</strong></strong></p>\r\n<p><strong>　</strong>　FPGA&nbsp;则独具匠心，其采用了<span style=\"color: #0000ff;\"> CMOS - SRAM&nbsp;</span>工艺制作。（其集成度可达百万门级）</p>\r\n<p>　　FPGA&nbsp;由三种可编程单元和一个用于存放编程数据的静态存储器组成。这三种可编程单元分别是<span style=\"color: #0000ff;\">输入/输出模块（IOB，Input Output Block）、可编程逻辑模块（CLB，Configurable Logic Block）和互连资源（IR，Interconnect Resource）</span>。而它们的工作状态全部都由编程数据存储器中的数据（比特流）设定。FPGA 基本电路结构框图如下所示：</p>\r\n<p><img style=\"display: block; margin-left: auto; margin-right: auto;\" src=\"https://img2018.cnblogs.com/blog/1442352/201909/1442352-20190928141903710-1679921427.png\" alt=\"\"></p>\r\n<p>　　除了 FPGA&nbsp;以外的 PLD&nbsp;器件，基本上都采用了与 - 或逻辑阵列加上输出逻辑单元的结构形式。而 FPGA&nbsp;则采用了完全不同的电路结构形式，它由若干独立的可编程逻辑模块组成，每个逻辑单元都是可编程的，用户可以通过编程将这些模块连接成所需要的数字系统。</p>\r\n<p>　　FPGA 的这种 CLB 阵列结构形式克服了 PAL 等 PLD 中那种固定的与-或逻辑阵列结构的局限性，在组成一些复杂的、特殊的数字系统时显得更加灵活。同时，由于加大了可编程 I/O 端的数目，也使得各引脚信号的安排更加方便和合理。</p>\r\n<p>　　不过&nbsp;FPGA 本身也存在着一些明显的缺点。首先，它的信号传输延迟时间不是确定的。在构成复杂的数字系统时一般总要将若干个 CLB 组合起来才能实现。而由于每个信号的传输途径各异，所以传输延迟时间也就不可能相等（CPLD&nbsp;的传输延时时间是确定的）。这不仅会给设计工作带来麻烦，而且也限制了器件的工作速度。在 CPLD 中就不存在这个问题。</p>\r\n<p>　　其次，由于 FPGA 中的编程数据存储器是一个静态随机存储器结构，所以断电后数据便随之丢失。因此，每次开始工作时都要重新装载编程数据，并需要配备保存编程数据的 EPROM。这些都给使用带来一些不便。</p>\r\n<p>　　此外，FPGA 的编程数据一般是存放在 EPROM 中的，而且要读出并送到 FPGA 的 SRAM 中，因而不便于保密。而 CPLD 中设有加密编程单元，加密后可以防止编程数据被读出。</p>\r\n<p>　　可见，FPGA 和 CPLD 各有不能取代的优点，这也正是两种器件目前都得到广泛应用的原因所在。</p>\r\n</div>', '2020-01-01', 0, 0, 0, 2, 4, 2);

SET FOREIGN_KEY_CHECKS = 1;
